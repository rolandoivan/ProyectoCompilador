Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> def_vars functions MAIN block
Rule 2     functions -> DEF type_fun ID LPARENTHESIS param RPARENTHESIS block functions
Rule 3     functions -> empty
Rule 4     param -> type ID COMMA param
Rule 5     param -> type ID
Rule 6     param -> empty
Rule 7     block -> LCURLY_BRACKET content_block RCURLY_BRACKET
Rule 8     content_block -> statment content_block
Rule 9     content_block -> empty
Rule 10    statment -> def_vars
Rule 11    statment -> assignment SEMICOLON
Rule 12    statment -> condition
Rule 13    statment -> while_loop
Rule 14    statment -> for_loop
Rule 15    statment -> function_call SEMICOLON
Rule 16    statment -> write_function
Rule 17    statment -> RETURN expression SEMICOLON
Rule 18    statment -> RETURN SEMICOLON
Rule 19    statment -> read_function
Rule 20    def_vars -> VAR type vars_n SEMICOLON def_vars
Rule 21    def_vars -> empty
Rule 22    vars_n -> ID COMMA vars_n
Rule 23    vars_n -> ID
Rule 24    vars_n -> ID LSQUARE_BRACKET CONST_INT RSQUARE_BRACKET
Rule 25    vars_n -> ID LSQUARE_BRACKET CONST_INT RSQUARE_BRACKET LSQUARE_BRACKET CONST_INT RSQUARE_BRACKET
Rule 26    assignment -> var ASSIGN expression
Rule 27    condition -> IF LPARENTHESIS expression RPARENTHESIS block condition_else
Rule 28    condition_else -> ELSE block
Rule 29    condition_else -> empty
Rule 30    while_loop -> WHILE LPARENTHESIS expression RPARENTHESIS block
Rule 31    while_loop -> DO block WHILE LPARENTHESIS expression RPARENTHESIS SEMICOLON
Rule 32    for_loop -> FOR LPARENTHESIS for_param1 for_param2 for_param3 RPARENTHESIS block
Rule 33    for_param1 -> assignment SEMICOLON
Rule 34    for_param2 -> expression SEMICOLON
Rule 35    for_param3 -> assignment
Rule 36    function_call -> ID LPARENTHESIS fun_param RPARENTHESIS
Rule 37    fun_param -> expression COMMA fun_param
Rule 38    fun_param -> expression
Rule 39    write_function -> PRINT LPARENTHESIS write RPARENTHESIS SEMICOLON
Rule 40    write -> expression COMMA write
Rule 41    write -> expression
Rule 42    read_function -> READ LPARENTHESIS read RPARENTHESIS SEMICOLON
Rule 43    read -> expression COMMA read
Rule 44    read -> expression
Rule 45    expression -> exp_or
Rule 46    expression -> expression logical_or exp_or
Rule 47    exp_or -> exp_and
Rule 48    exp_or -> exp_or logical_and exp_and
Rule 49    exp_and -> exp_not
Rule 50    exp_and -> exp_and logical_not exp_not
Rule 51    exp_not -> exp
Rule 52    exp_not -> exp relational_l1 term
Rule 53    exp_not -> exp relational_l2 term
Rule 54    exp -> term
Rule 55    exp -> term arithmetic_l1 exp
Rule 56    term -> factor
Rule 57    term -> factor arithmetic_l2 term
Rule 58    factor -> LPARENTHESIS expression RPARENTHESIS
Rule 59    factor -> const_var
Rule 60    factor -> function_call
Rule 61    factor -> var
Rule 62    arithmetic_l1 -> PLUS
Rule 63    arithmetic_l1 -> MINUS
Rule 64    arithmetic_l2 -> TIMES
Rule 65    arithmetic_l2 -> DIVIDE
Rule 66    relational_l1 -> EQUALS
Rule 67    relational_l1 -> NOT_EQUALS
Rule 68    relational_l2 -> LT
Rule 69    relational_l2 -> GT
Rule 70    relational_l2 -> LTE
Rule 71    relational_l2 -> GTE
Rule 72    logical_or -> BOOL_OR
Rule 73    logical_and -> BOOL_AND
Rule 74    logical_not -> BOOL_NOT
Rule 75    const_var -> CONST_INT
Rule 76    const_var -> CONST_FLOAT
Rule 77    const_var -> CONST_STRING
Rule 78    var -> ID
Rule 79    var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET
Rule 80    var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET
Rule 81    type -> INT
Rule 82    type -> FLOAT
Rule 83    type -> STRING
Rule 84    type -> BOOL
Rule 85    type_fun -> type
Rule 86    type_fun -> VOID
Rule 87    empty -> <empty>

Terminals, with rules where they appear

ASSIGN               : 26
BOOL                 : 84
BOOL_AND             : 73
BOOL_NOT             : 74
BOOL_OR              : 72
COMMA                : 4 22 37 40 43
CONST_FLOAT          : 76
CONST_INT            : 24 25 25 75
CONST_STRING         : 77
DEF                  : 2
DIVIDE               : 65
DO                   : 31
ELSE                 : 28
EQUALS               : 66
FLOAT                : 82
FOR                  : 32
GT                   : 69
GTE                  : 71
ID                   : 2 4 5 22 23 24 25 36 78 79 80
IF                   : 27
INT                  : 81
LCURLY_BRACKET       : 7
LPARENTHESIS         : 2 27 30 31 32 36 39 42 58
LSQUARE_BRACKET      : 24 25 25 79 80 80
LT                   : 68
LTE                  : 70
MAIN                 : 1
MINUS                : 63
NOT_EQUALS           : 67
PLUS                 : 62
PRINT                : 39
RCURLY_BRACKET       : 7
READ                 : 42
RETURN               : 17 18
RPARENTHESIS         : 2 27 30 31 32 36 39 42 58
RSQUARE_BRACKET      : 24 25 25 79 80 80
SEMICOLON            : 11 15 17 18 20 31 33 34 39 42
STRING               : 83
TIMES                : 64
VAR                  : 20
VOID                 : 86
WHILE                : 30 31
error                : 

Nonterminals, with rules where they appear

arithmetic_l1        : 55
arithmetic_l2        : 57
assignment           : 11 33 35
block                : 1 2 27 28 30 31 32
condition            : 12
condition_else       : 27
const_var            : 59
content_block        : 7 8
def_vars             : 1 10 20
empty                : 3 6 9 21 29
exp                  : 51 52 53 55
exp_and              : 47 48 50
exp_not              : 49 50
exp_or               : 45 46 48
expression           : 17 26 27 30 31 34 37 38 40 41 43 44 46 58 79 80 80
factor               : 56 57
for_loop             : 14
for_param1           : 32
for_param2           : 32
for_param3           : 32
fun_param            : 36 37
function_call        : 15 60
functions            : 1 2
logical_and          : 48
logical_not          : 50
logical_or           : 46
param                : 2 4
program              : 0
read                 : 42 43
read_function        : 19
relational_l1        : 52
relational_l2        : 53
statment             : 8
term                 : 52 53 54 55 57
type                 : 4 5 20 85
type_fun             : 2
var                  : 26 61
vars_n               : 20 22
while_loop           : 13
write                : 39 40
write_function       : 16

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . def_vars functions MAIN block
    (20) def_vars -> . VAR type vars_n SEMICOLON def_vars
    (21) def_vars -> . empty
    (87) empty -> .

    VAR             shift and go to state 3
    DEF             reduce using rule 87 (empty -> .)
    MAIN            reduce using rule 87 (empty -> .)

    program                        shift and go to state 1
    def_vars                       shift and go to state 2
    empty                          shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> def_vars . functions MAIN block
    (2) functions -> . DEF type_fun ID LPARENTHESIS param RPARENTHESIS block functions
    (3) functions -> . empty
    (87) empty -> .

    DEF             shift and go to state 6
    MAIN            reduce using rule 87 (empty -> .)

    functions                      shift and go to state 5
    empty                          shift and go to state 7

state 3

    (20) def_vars -> VAR . type vars_n SEMICOLON def_vars
    (81) type -> . INT
    (82) type -> . FLOAT
    (83) type -> . STRING
    (84) type -> . BOOL

    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    STRING          shift and go to state 11
    BOOL            shift and go to state 12

    type                           shift and go to state 8

state 4

    (21) def_vars -> empty .

    DEF             reduce using rule 21 (def_vars -> empty .)
    MAIN            reduce using rule 21 (def_vars -> empty .)
    RETURN          reduce using rule 21 (def_vars -> empty .)
    VAR             reduce using rule 21 (def_vars -> empty .)
    IF              reduce using rule 21 (def_vars -> empty .)
    WHILE           reduce using rule 21 (def_vars -> empty .)
    DO              reduce using rule 21 (def_vars -> empty .)
    FOR             reduce using rule 21 (def_vars -> empty .)
    ID              reduce using rule 21 (def_vars -> empty .)
    PRINT           reduce using rule 21 (def_vars -> empty .)
    READ            reduce using rule 21 (def_vars -> empty .)
    RCURLY_BRACKET  reduce using rule 21 (def_vars -> empty .)


state 5

    (1) program -> def_vars functions . MAIN block

    MAIN            shift and go to state 13


state 6

    (2) functions -> DEF . type_fun ID LPARENTHESIS param RPARENTHESIS block functions
    (85) type_fun -> . type
    (86) type_fun -> . VOID
    (81) type -> . INT
    (82) type -> . FLOAT
    (83) type -> . STRING
    (84) type -> . BOOL

    VOID            shift and go to state 16
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    STRING          shift and go to state 11
    BOOL            shift and go to state 12

    type_fun                       shift and go to state 14
    type                           shift and go to state 15

state 7

    (3) functions -> empty .

    MAIN            reduce using rule 3 (functions -> empty .)


state 8

    (20) def_vars -> VAR type . vars_n SEMICOLON def_vars
    (22) vars_n -> . ID COMMA vars_n
    (23) vars_n -> . ID
    (24) vars_n -> . ID LSQUARE_BRACKET CONST_INT RSQUARE_BRACKET
    (25) vars_n -> . ID LSQUARE_BRACKET CONST_INT RSQUARE_BRACKET LSQUARE_BRACKET CONST_INT RSQUARE_BRACKET

    ID              shift and go to state 18

    vars_n                         shift and go to state 17

state 9

    (81) type -> INT .

    ID              reduce using rule 81 (type -> INT .)


state 10

    (82) type -> FLOAT .

    ID              reduce using rule 82 (type -> FLOAT .)


state 11

    (83) type -> STRING .

    ID              reduce using rule 83 (type -> STRING .)


state 12

    (84) type -> BOOL .

    ID              reduce using rule 84 (type -> BOOL .)


state 13

    (1) program -> def_vars functions MAIN . block
    (7) block -> . LCURLY_BRACKET content_block RCURLY_BRACKET

    LCURLY_BRACKET  shift and go to state 20

    block                          shift and go to state 19

state 14

    (2) functions -> DEF type_fun . ID LPARENTHESIS param RPARENTHESIS block functions

    ID              shift and go to state 21


state 15

    (85) type_fun -> type .

    ID              reduce using rule 85 (type_fun -> type .)


state 16

    (86) type_fun -> VOID .

    ID              reduce using rule 86 (type_fun -> VOID .)


state 17

    (20) def_vars -> VAR type vars_n . SEMICOLON def_vars

    SEMICOLON       shift and go to state 22


state 18

    (22) vars_n -> ID . COMMA vars_n
    (23) vars_n -> ID .
    (24) vars_n -> ID . LSQUARE_BRACKET CONST_INT RSQUARE_BRACKET
    (25) vars_n -> ID . LSQUARE_BRACKET CONST_INT RSQUARE_BRACKET LSQUARE_BRACKET CONST_INT RSQUARE_BRACKET

    COMMA           shift and go to state 23
    SEMICOLON       reduce using rule 23 (vars_n -> ID .)
    LSQUARE_BRACKET shift and go to state 24


state 19

    (1) program -> def_vars functions MAIN block .

    $end            reduce using rule 1 (program -> def_vars functions MAIN block .)


state 20

    (7) block -> LCURLY_BRACKET . content_block RCURLY_BRACKET
    (8) content_block -> . statment content_block
    (9) content_block -> . empty
    (10) statment -> . def_vars
    (11) statment -> . assignment SEMICOLON
    (12) statment -> . condition
    (13) statment -> . while_loop
    (14) statment -> . for_loop
    (15) statment -> . function_call SEMICOLON
    (16) statment -> . write_function
    (17) statment -> . RETURN expression SEMICOLON
    (18) statment -> . RETURN SEMICOLON
    (19) statment -> . read_function
    (87) empty -> .
    (20) def_vars -> . VAR type vars_n SEMICOLON def_vars
    (21) def_vars -> . empty
    (26) assignment -> . var ASSIGN expression
    (27) condition -> . IF LPARENTHESIS expression RPARENTHESIS block condition_else
    (30) while_loop -> . WHILE LPARENTHESIS expression RPARENTHESIS block
    (31) while_loop -> . DO block WHILE LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (32) for_loop -> . FOR LPARENTHESIS for_param1 for_param2 for_param3 RPARENTHESIS block
    (36) function_call -> . ID LPARENTHESIS fun_param RPARENTHESIS
    (39) write_function -> . PRINT LPARENTHESIS write RPARENTHESIS SEMICOLON
    (42) read_function -> . READ LPARENTHESIS read RPARENTHESIS SEMICOLON
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for DO resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for READ resolved as shift
    RETURN          shift and go to state 35
    RCURLY_BRACKET  reduce using rule 87 (empty -> .)
    VAR             shift and go to state 3
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    DO              shift and go to state 40
    FOR             shift and go to state 41
    ID              shift and go to state 42
    PRINT           shift and go to state 43
    READ            shift and go to state 44

  ! RETURN          [ reduce using rule 87 (empty -> .) ]
  ! VAR             [ reduce using rule 87 (empty -> .) ]
  ! IF              [ reduce using rule 87 (empty -> .) ]
  ! WHILE           [ reduce using rule 87 (empty -> .) ]
  ! DO              [ reduce using rule 87 (empty -> .) ]
  ! FOR             [ reduce using rule 87 (empty -> .) ]
  ! ID              [ reduce using rule 87 (empty -> .) ]
  ! PRINT           [ reduce using rule 87 (empty -> .) ]
  ! READ            [ reduce using rule 87 (empty -> .) ]

    content_block                  shift and go to state 25
    statment                       shift and go to state 26
    empty                          shift and go to state 27
    def_vars                       shift and go to state 28
    assignment                     shift and go to state 29
    condition                      shift and go to state 30
    while_loop                     shift and go to state 31
    for_loop                       shift and go to state 32
    function_call                  shift and go to state 33
    write_function                 shift and go to state 34
    read_function                  shift and go to state 36
    var                            shift and go to state 37

state 21

    (2) functions -> DEF type_fun ID . LPARENTHESIS param RPARENTHESIS block functions

    LPARENTHESIS    shift and go to state 45


state 22

    (20) def_vars -> VAR type vars_n SEMICOLON . def_vars
    (20) def_vars -> . VAR type vars_n SEMICOLON def_vars
    (21) def_vars -> . empty
    (87) empty -> .

  ! shift/reduce conflict for VAR resolved as shift
    VAR             shift and go to state 3
    DEF             reduce using rule 87 (empty -> .)
    MAIN            reduce using rule 87 (empty -> .)
    RETURN          reduce using rule 87 (empty -> .)
    IF              reduce using rule 87 (empty -> .)
    WHILE           reduce using rule 87 (empty -> .)
    DO              reduce using rule 87 (empty -> .)
    FOR             reduce using rule 87 (empty -> .)
    ID              reduce using rule 87 (empty -> .)
    PRINT           reduce using rule 87 (empty -> .)
    READ            reduce using rule 87 (empty -> .)
    RCURLY_BRACKET  reduce using rule 87 (empty -> .)

  ! VAR             [ reduce using rule 87 (empty -> .) ]

    def_vars                       shift and go to state 46
    empty                          shift and go to state 4

state 23

    (22) vars_n -> ID COMMA . vars_n
    (22) vars_n -> . ID COMMA vars_n
    (23) vars_n -> . ID
    (24) vars_n -> . ID LSQUARE_BRACKET CONST_INT RSQUARE_BRACKET
    (25) vars_n -> . ID LSQUARE_BRACKET CONST_INT RSQUARE_BRACKET LSQUARE_BRACKET CONST_INT RSQUARE_BRACKET

    ID              shift and go to state 18

    vars_n                         shift and go to state 47

state 24

    (24) vars_n -> ID LSQUARE_BRACKET . CONST_INT RSQUARE_BRACKET
    (25) vars_n -> ID LSQUARE_BRACKET . CONST_INT RSQUARE_BRACKET LSQUARE_BRACKET CONST_INT RSQUARE_BRACKET

    CONST_INT       shift and go to state 48


state 25

    (7) block -> LCURLY_BRACKET content_block . RCURLY_BRACKET

    RCURLY_BRACKET  shift and go to state 49


state 26

    (8) content_block -> statment . content_block
    (8) content_block -> . statment content_block
    (9) content_block -> . empty
    (10) statment -> . def_vars
    (11) statment -> . assignment SEMICOLON
    (12) statment -> . condition
    (13) statment -> . while_loop
    (14) statment -> . for_loop
    (15) statment -> . function_call SEMICOLON
    (16) statment -> . write_function
    (17) statment -> . RETURN expression SEMICOLON
    (18) statment -> . RETURN SEMICOLON
    (19) statment -> . read_function
    (87) empty -> .
    (20) def_vars -> . VAR type vars_n SEMICOLON def_vars
    (21) def_vars -> . empty
    (26) assignment -> . var ASSIGN expression
    (27) condition -> . IF LPARENTHESIS expression RPARENTHESIS block condition_else
    (30) while_loop -> . WHILE LPARENTHESIS expression RPARENTHESIS block
    (31) while_loop -> . DO block WHILE LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (32) for_loop -> . FOR LPARENTHESIS for_param1 for_param2 for_param3 RPARENTHESIS block
    (36) function_call -> . ID LPARENTHESIS fun_param RPARENTHESIS
    (39) write_function -> . PRINT LPARENTHESIS write RPARENTHESIS SEMICOLON
    (42) read_function -> . READ LPARENTHESIS read RPARENTHESIS SEMICOLON
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for DO resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for READ resolved as shift
    RETURN          shift and go to state 35
    RCURLY_BRACKET  reduce using rule 87 (empty -> .)
    VAR             shift and go to state 3
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    DO              shift and go to state 40
    FOR             shift and go to state 41
    ID              shift and go to state 42
    PRINT           shift and go to state 43
    READ            shift and go to state 44

  ! RETURN          [ reduce using rule 87 (empty -> .) ]
  ! VAR             [ reduce using rule 87 (empty -> .) ]
  ! IF              [ reduce using rule 87 (empty -> .) ]
  ! WHILE           [ reduce using rule 87 (empty -> .) ]
  ! DO              [ reduce using rule 87 (empty -> .) ]
  ! FOR             [ reduce using rule 87 (empty -> .) ]
  ! ID              [ reduce using rule 87 (empty -> .) ]
  ! PRINT           [ reduce using rule 87 (empty -> .) ]
  ! READ            [ reduce using rule 87 (empty -> .) ]

    statment                       shift and go to state 26
    content_block                  shift and go to state 50
    empty                          shift and go to state 27
    def_vars                       shift and go to state 28
    assignment                     shift and go to state 29
    condition                      shift and go to state 30
    while_loop                     shift and go to state 31
    for_loop                       shift and go to state 32
    function_call                  shift and go to state 33
    write_function                 shift and go to state 34
    read_function                  shift and go to state 36
    var                            shift and go to state 37

state 27

    (9) content_block -> empty .
    (21) def_vars -> empty .

  ! reduce/reduce conflict for RCURLY_BRACKET resolved using rule 9 (content_block -> empty .)
    RCURLY_BRACKET  reduce using rule 9 (content_block -> empty .)
    RETURN          reduce using rule 21 (def_vars -> empty .)
    VAR             reduce using rule 21 (def_vars -> empty .)
    IF              reduce using rule 21 (def_vars -> empty .)
    WHILE           reduce using rule 21 (def_vars -> empty .)
    DO              reduce using rule 21 (def_vars -> empty .)
    FOR             reduce using rule 21 (def_vars -> empty .)
    ID              reduce using rule 21 (def_vars -> empty .)
    PRINT           reduce using rule 21 (def_vars -> empty .)
    READ            reduce using rule 21 (def_vars -> empty .)

  ! RCURLY_BRACKET  [ reduce using rule 21 (def_vars -> empty .) ]


state 28

    (10) statment -> def_vars .

    RETURN          reduce using rule 10 (statment -> def_vars .)
    VAR             reduce using rule 10 (statment -> def_vars .)
    IF              reduce using rule 10 (statment -> def_vars .)
    WHILE           reduce using rule 10 (statment -> def_vars .)
    DO              reduce using rule 10 (statment -> def_vars .)
    FOR             reduce using rule 10 (statment -> def_vars .)
    ID              reduce using rule 10 (statment -> def_vars .)
    PRINT           reduce using rule 10 (statment -> def_vars .)
    READ            reduce using rule 10 (statment -> def_vars .)
    RCURLY_BRACKET  reduce using rule 10 (statment -> def_vars .)


state 29

    (11) statment -> assignment . SEMICOLON

    SEMICOLON       shift and go to state 51


state 30

    (12) statment -> condition .

    RETURN          reduce using rule 12 (statment -> condition .)
    VAR             reduce using rule 12 (statment -> condition .)
    IF              reduce using rule 12 (statment -> condition .)
    WHILE           reduce using rule 12 (statment -> condition .)
    DO              reduce using rule 12 (statment -> condition .)
    FOR             reduce using rule 12 (statment -> condition .)
    ID              reduce using rule 12 (statment -> condition .)
    PRINT           reduce using rule 12 (statment -> condition .)
    READ            reduce using rule 12 (statment -> condition .)
    RCURLY_BRACKET  reduce using rule 12 (statment -> condition .)


state 31

    (13) statment -> while_loop .

    RETURN          reduce using rule 13 (statment -> while_loop .)
    VAR             reduce using rule 13 (statment -> while_loop .)
    IF              reduce using rule 13 (statment -> while_loop .)
    WHILE           reduce using rule 13 (statment -> while_loop .)
    DO              reduce using rule 13 (statment -> while_loop .)
    FOR             reduce using rule 13 (statment -> while_loop .)
    ID              reduce using rule 13 (statment -> while_loop .)
    PRINT           reduce using rule 13 (statment -> while_loop .)
    READ            reduce using rule 13 (statment -> while_loop .)
    RCURLY_BRACKET  reduce using rule 13 (statment -> while_loop .)


state 32

    (14) statment -> for_loop .

    RETURN          reduce using rule 14 (statment -> for_loop .)
    VAR             reduce using rule 14 (statment -> for_loop .)
    IF              reduce using rule 14 (statment -> for_loop .)
    WHILE           reduce using rule 14 (statment -> for_loop .)
    DO              reduce using rule 14 (statment -> for_loop .)
    FOR             reduce using rule 14 (statment -> for_loop .)
    ID              reduce using rule 14 (statment -> for_loop .)
    PRINT           reduce using rule 14 (statment -> for_loop .)
    READ            reduce using rule 14 (statment -> for_loop .)
    RCURLY_BRACKET  reduce using rule 14 (statment -> for_loop .)


state 33

    (15) statment -> function_call . SEMICOLON

    SEMICOLON       shift and go to state 52


state 34

    (16) statment -> write_function .

    RETURN          reduce using rule 16 (statment -> write_function .)
    VAR             reduce using rule 16 (statment -> write_function .)
    IF              reduce using rule 16 (statment -> write_function .)
    WHILE           reduce using rule 16 (statment -> write_function .)
    DO              reduce using rule 16 (statment -> write_function .)
    FOR             reduce using rule 16 (statment -> write_function .)
    ID              reduce using rule 16 (statment -> write_function .)
    PRINT           reduce using rule 16 (statment -> write_function .)
    READ            reduce using rule 16 (statment -> write_function .)
    RCURLY_BRACKET  reduce using rule 16 (statment -> write_function .)


state 35

    (17) statment -> RETURN . expression SEMICOLON
    (18) statment -> RETURN . SEMICOLON
    (45) expression -> . exp_or
    (46) expression -> . expression logical_or exp_or
    (47) exp_or -> . exp_and
    (48) exp_or -> . exp_or logical_and exp_and
    (49) exp_and -> . exp_not
    (50) exp_and -> . exp_and logical_not exp_not
    (51) exp_not -> . exp
    (52) exp_not -> . exp relational_l1 term
    (53) exp_not -> . exp relational_l2 term
    (54) exp -> . term
    (55) exp -> . term arithmetic_l1 exp
    (56) term -> . factor
    (57) term -> . factor arithmetic_l2 term
    (58) factor -> . LPARENTHESIS expression RPARENTHESIS
    (59) factor -> . const_var
    (60) factor -> . function_call
    (61) factor -> . var
    (75) const_var -> . CONST_INT
    (76) const_var -> . CONST_FLOAT
    (77) const_var -> . CONST_STRING
    (36) function_call -> . ID LPARENTHESIS fun_param RPARENTHESIS
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    SEMICOLON       shift and go to state 54
    LPARENTHESIS    shift and go to state 61
    CONST_INT       shift and go to state 65
    CONST_FLOAT     shift and go to state 66
    CONST_STRING    shift and go to state 67
    ID              shift and go to state 42

    expression                     shift and go to state 53
    exp_or                         shift and go to state 55
    exp_and                        shift and go to state 56
    exp_not                        shift and go to state 57
    exp                            shift and go to state 58
    term                           shift and go to state 59
    factor                         shift and go to state 60
    const_var                      shift and go to state 62
    function_call                  shift and go to state 63
    var                            shift and go to state 64

state 36

    (19) statment -> read_function .

    RETURN          reduce using rule 19 (statment -> read_function .)
    VAR             reduce using rule 19 (statment -> read_function .)
    IF              reduce using rule 19 (statment -> read_function .)
    WHILE           reduce using rule 19 (statment -> read_function .)
    DO              reduce using rule 19 (statment -> read_function .)
    FOR             reduce using rule 19 (statment -> read_function .)
    ID              reduce using rule 19 (statment -> read_function .)
    PRINT           reduce using rule 19 (statment -> read_function .)
    READ            reduce using rule 19 (statment -> read_function .)
    RCURLY_BRACKET  reduce using rule 19 (statment -> read_function .)


state 37

    (26) assignment -> var . ASSIGN expression

    ASSIGN          shift and go to state 68


state 38

    (27) condition -> IF . LPARENTHESIS expression RPARENTHESIS block condition_else

    LPARENTHESIS    shift and go to state 69


state 39

    (30) while_loop -> WHILE . LPARENTHESIS expression RPARENTHESIS block

    LPARENTHESIS    shift and go to state 70


state 40

    (31) while_loop -> DO . block WHILE LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (7) block -> . LCURLY_BRACKET content_block RCURLY_BRACKET

    LCURLY_BRACKET  shift and go to state 20

    block                          shift and go to state 71

state 41

    (32) for_loop -> FOR . LPARENTHESIS for_param1 for_param2 for_param3 RPARENTHESIS block

    LPARENTHESIS    shift and go to state 72


state 42

    (36) function_call -> ID . LPARENTHESIS fun_param RPARENTHESIS
    (78) var -> ID .
    (79) var -> ID . LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> ID . LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    LPARENTHESIS    shift and go to state 73
    ASSIGN          reduce using rule 78 (var -> ID .)
    TIMES           reduce using rule 78 (var -> ID .)
    DIVIDE          reduce using rule 78 (var -> ID .)
    PLUS            reduce using rule 78 (var -> ID .)
    MINUS           reduce using rule 78 (var -> ID .)
    EQUALS          reduce using rule 78 (var -> ID .)
    NOT_EQUALS      reduce using rule 78 (var -> ID .)
    LT              reduce using rule 78 (var -> ID .)
    GT              reduce using rule 78 (var -> ID .)
    LTE             reduce using rule 78 (var -> ID .)
    GTE             reduce using rule 78 (var -> ID .)
    BOOL_NOT        reduce using rule 78 (var -> ID .)
    BOOL_AND        reduce using rule 78 (var -> ID .)
    SEMICOLON       reduce using rule 78 (var -> ID .)
    BOOL_OR         reduce using rule 78 (var -> ID .)
    RPARENTHESIS    reduce using rule 78 (var -> ID .)
    COMMA           reduce using rule 78 (var -> ID .)
    RSQUARE_BRACKET reduce using rule 78 (var -> ID .)
    LSQUARE_BRACKET shift and go to state 74


state 43

    (39) write_function -> PRINT . LPARENTHESIS write RPARENTHESIS SEMICOLON

    LPARENTHESIS    shift and go to state 75


state 44

    (42) read_function -> READ . LPARENTHESIS read RPARENTHESIS SEMICOLON

    LPARENTHESIS    shift and go to state 76


state 45

    (2) functions -> DEF type_fun ID LPARENTHESIS . param RPARENTHESIS block functions
    (4) param -> . type ID COMMA param
    (5) param -> . type ID
    (6) param -> . empty
    (81) type -> . INT
    (82) type -> . FLOAT
    (83) type -> . STRING
    (84) type -> . BOOL
    (87) empty -> .

    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    RPARENTHESIS    reduce using rule 87 (empty -> .)

    param                          shift and go to state 77
    type                           shift and go to state 78
    empty                          shift and go to state 79

state 46

    (20) def_vars -> VAR type vars_n SEMICOLON def_vars .

    DEF             reduce using rule 20 (def_vars -> VAR type vars_n SEMICOLON def_vars .)
    MAIN            reduce using rule 20 (def_vars -> VAR type vars_n SEMICOLON def_vars .)
    RETURN          reduce using rule 20 (def_vars -> VAR type vars_n SEMICOLON def_vars .)
    VAR             reduce using rule 20 (def_vars -> VAR type vars_n SEMICOLON def_vars .)
    IF              reduce using rule 20 (def_vars -> VAR type vars_n SEMICOLON def_vars .)
    WHILE           reduce using rule 20 (def_vars -> VAR type vars_n SEMICOLON def_vars .)
    DO              reduce using rule 20 (def_vars -> VAR type vars_n SEMICOLON def_vars .)
    FOR             reduce using rule 20 (def_vars -> VAR type vars_n SEMICOLON def_vars .)
    ID              reduce using rule 20 (def_vars -> VAR type vars_n SEMICOLON def_vars .)
    PRINT           reduce using rule 20 (def_vars -> VAR type vars_n SEMICOLON def_vars .)
    READ            reduce using rule 20 (def_vars -> VAR type vars_n SEMICOLON def_vars .)
    RCURLY_BRACKET  reduce using rule 20 (def_vars -> VAR type vars_n SEMICOLON def_vars .)


state 47

    (22) vars_n -> ID COMMA vars_n .

    SEMICOLON       reduce using rule 22 (vars_n -> ID COMMA vars_n .)


state 48

    (24) vars_n -> ID LSQUARE_BRACKET CONST_INT . RSQUARE_BRACKET
    (25) vars_n -> ID LSQUARE_BRACKET CONST_INT . RSQUARE_BRACKET LSQUARE_BRACKET CONST_INT RSQUARE_BRACKET

    RSQUARE_BRACKET shift and go to state 80


state 49

    (7) block -> LCURLY_BRACKET content_block RCURLY_BRACKET .

    $end            reduce using rule 7 (block -> LCURLY_BRACKET content_block RCURLY_BRACKET .)
    WHILE           reduce using rule 7 (block -> LCURLY_BRACKET content_block RCURLY_BRACKET .)
    DEF             reduce using rule 7 (block -> LCURLY_BRACKET content_block RCURLY_BRACKET .)
    MAIN            reduce using rule 7 (block -> LCURLY_BRACKET content_block RCURLY_BRACKET .)
    ELSE            reduce using rule 7 (block -> LCURLY_BRACKET content_block RCURLY_BRACKET .)
    RETURN          reduce using rule 7 (block -> LCURLY_BRACKET content_block RCURLY_BRACKET .)
    VAR             reduce using rule 7 (block -> LCURLY_BRACKET content_block RCURLY_BRACKET .)
    IF              reduce using rule 7 (block -> LCURLY_BRACKET content_block RCURLY_BRACKET .)
    DO              reduce using rule 7 (block -> LCURLY_BRACKET content_block RCURLY_BRACKET .)
    FOR             reduce using rule 7 (block -> LCURLY_BRACKET content_block RCURLY_BRACKET .)
    ID              reduce using rule 7 (block -> LCURLY_BRACKET content_block RCURLY_BRACKET .)
    PRINT           reduce using rule 7 (block -> LCURLY_BRACKET content_block RCURLY_BRACKET .)
    READ            reduce using rule 7 (block -> LCURLY_BRACKET content_block RCURLY_BRACKET .)
    RCURLY_BRACKET  reduce using rule 7 (block -> LCURLY_BRACKET content_block RCURLY_BRACKET .)


state 50

    (8) content_block -> statment content_block .

    RCURLY_BRACKET  reduce using rule 8 (content_block -> statment content_block .)


state 51

    (11) statment -> assignment SEMICOLON .

    RETURN          reduce using rule 11 (statment -> assignment SEMICOLON .)
    VAR             reduce using rule 11 (statment -> assignment SEMICOLON .)
    IF              reduce using rule 11 (statment -> assignment SEMICOLON .)
    WHILE           reduce using rule 11 (statment -> assignment SEMICOLON .)
    DO              reduce using rule 11 (statment -> assignment SEMICOLON .)
    FOR             reduce using rule 11 (statment -> assignment SEMICOLON .)
    ID              reduce using rule 11 (statment -> assignment SEMICOLON .)
    PRINT           reduce using rule 11 (statment -> assignment SEMICOLON .)
    READ            reduce using rule 11 (statment -> assignment SEMICOLON .)
    RCURLY_BRACKET  reduce using rule 11 (statment -> assignment SEMICOLON .)


state 52

    (15) statment -> function_call SEMICOLON .

    RETURN          reduce using rule 15 (statment -> function_call SEMICOLON .)
    VAR             reduce using rule 15 (statment -> function_call SEMICOLON .)
    IF              reduce using rule 15 (statment -> function_call SEMICOLON .)
    WHILE           reduce using rule 15 (statment -> function_call SEMICOLON .)
    DO              reduce using rule 15 (statment -> function_call SEMICOLON .)
    FOR             reduce using rule 15 (statment -> function_call SEMICOLON .)
    ID              reduce using rule 15 (statment -> function_call SEMICOLON .)
    PRINT           reduce using rule 15 (statment -> function_call SEMICOLON .)
    READ            reduce using rule 15 (statment -> function_call SEMICOLON .)
    RCURLY_BRACKET  reduce using rule 15 (statment -> function_call SEMICOLON .)


state 53

    (17) statment -> RETURN expression . SEMICOLON
    (46) expression -> expression . logical_or exp_or
    (72) logical_or -> . BOOL_OR

    SEMICOLON       shift and go to state 81
    BOOL_OR         shift and go to state 83

    logical_or                     shift and go to state 82

state 54

    (18) statment -> RETURN SEMICOLON .

    RETURN          reduce using rule 18 (statment -> RETURN SEMICOLON .)
    VAR             reduce using rule 18 (statment -> RETURN SEMICOLON .)
    IF              reduce using rule 18 (statment -> RETURN SEMICOLON .)
    WHILE           reduce using rule 18 (statment -> RETURN SEMICOLON .)
    DO              reduce using rule 18 (statment -> RETURN SEMICOLON .)
    FOR             reduce using rule 18 (statment -> RETURN SEMICOLON .)
    ID              reduce using rule 18 (statment -> RETURN SEMICOLON .)
    PRINT           reduce using rule 18 (statment -> RETURN SEMICOLON .)
    READ            reduce using rule 18 (statment -> RETURN SEMICOLON .)
    RCURLY_BRACKET  reduce using rule 18 (statment -> RETURN SEMICOLON .)


state 55

    (45) expression -> exp_or .
    (48) exp_or -> exp_or . logical_and exp_and
    (73) logical_and -> . BOOL_AND

    SEMICOLON       reduce using rule 45 (expression -> exp_or .)
    BOOL_OR         reduce using rule 45 (expression -> exp_or .)
    RPARENTHESIS    reduce using rule 45 (expression -> exp_or .)
    COMMA           reduce using rule 45 (expression -> exp_or .)
    RSQUARE_BRACKET reduce using rule 45 (expression -> exp_or .)
    BOOL_AND        shift and go to state 85

    logical_and                    shift and go to state 84

state 56

    (47) exp_or -> exp_and .
    (50) exp_and -> exp_and . logical_not exp_not
    (74) logical_not -> . BOOL_NOT

    BOOL_AND        reduce using rule 47 (exp_or -> exp_and .)
    SEMICOLON       reduce using rule 47 (exp_or -> exp_and .)
    BOOL_OR         reduce using rule 47 (exp_or -> exp_and .)
    RPARENTHESIS    reduce using rule 47 (exp_or -> exp_and .)
    COMMA           reduce using rule 47 (exp_or -> exp_and .)
    RSQUARE_BRACKET reduce using rule 47 (exp_or -> exp_and .)
    BOOL_NOT        shift and go to state 87

    logical_not                    shift and go to state 86

state 57

    (49) exp_and -> exp_not .

    BOOL_NOT        reduce using rule 49 (exp_and -> exp_not .)
    BOOL_AND        reduce using rule 49 (exp_and -> exp_not .)
    SEMICOLON       reduce using rule 49 (exp_and -> exp_not .)
    BOOL_OR         reduce using rule 49 (exp_and -> exp_not .)
    RPARENTHESIS    reduce using rule 49 (exp_and -> exp_not .)
    COMMA           reduce using rule 49 (exp_and -> exp_not .)
    RSQUARE_BRACKET reduce using rule 49 (exp_and -> exp_not .)


state 58

    (51) exp_not -> exp .
    (52) exp_not -> exp . relational_l1 term
    (53) exp_not -> exp . relational_l2 term
    (66) relational_l1 -> . EQUALS
    (67) relational_l1 -> . NOT_EQUALS
    (68) relational_l2 -> . LT
    (69) relational_l2 -> . GT
    (70) relational_l2 -> . LTE
    (71) relational_l2 -> . GTE

    BOOL_NOT        reduce using rule 51 (exp_not -> exp .)
    BOOL_AND        reduce using rule 51 (exp_not -> exp .)
    SEMICOLON       reduce using rule 51 (exp_not -> exp .)
    BOOL_OR         reduce using rule 51 (exp_not -> exp .)
    RPARENTHESIS    reduce using rule 51 (exp_not -> exp .)
    COMMA           reduce using rule 51 (exp_not -> exp .)
    RSQUARE_BRACKET reduce using rule 51 (exp_not -> exp .)
    EQUALS          shift and go to state 90
    NOT_EQUALS      shift and go to state 91
    LT              shift and go to state 92
    GT              shift and go to state 93
    LTE             shift and go to state 94
    GTE             shift and go to state 95

    relational_l1                  shift and go to state 88
    relational_l2                  shift and go to state 89

state 59

    (54) exp -> term .
    (55) exp -> term . arithmetic_l1 exp
    (62) arithmetic_l1 -> . PLUS
    (63) arithmetic_l1 -> . MINUS

    EQUALS          reduce using rule 54 (exp -> term .)
    NOT_EQUALS      reduce using rule 54 (exp -> term .)
    LT              reduce using rule 54 (exp -> term .)
    GT              reduce using rule 54 (exp -> term .)
    LTE             reduce using rule 54 (exp -> term .)
    GTE             reduce using rule 54 (exp -> term .)
    BOOL_NOT        reduce using rule 54 (exp -> term .)
    BOOL_AND        reduce using rule 54 (exp -> term .)
    SEMICOLON       reduce using rule 54 (exp -> term .)
    BOOL_OR         reduce using rule 54 (exp -> term .)
    RPARENTHESIS    reduce using rule 54 (exp -> term .)
    COMMA           reduce using rule 54 (exp -> term .)
    RSQUARE_BRACKET reduce using rule 54 (exp -> term .)
    PLUS            shift and go to state 97
    MINUS           shift and go to state 98

    arithmetic_l1                  shift and go to state 96

state 60

    (56) term -> factor .
    (57) term -> factor . arithmetic_l2 term
    (64) arithmetic_l2 -> . TIMES
    (65) arithmetic_l2 -> . DIVIDE

    PLUS            reduce using rule 56 (term -> factor .)
    MINUS           reduce using rule 56 (term -> factor .)
    EQUALS          reduce using rule 56 (term -> factor .)
    NOT_EQUALS      reduce using rule 56 (term -> factor .)
    LT              reduce using rule 56 (term -> factor .)
    GT              reduce using rule 56 (term -> factor .)
    LTE             reduce using rule 56 (term -> factor .)
    GTE             reduce using rule 56 (term -> factor .)
    BOOL_NOT        reduce using rule 56 (term -> factor .)
    BOOL_AND        reduce using rule 56 (term -> factor .)
    SEMICOLON       reduce using rule 56 (term -> factor .)
    BOOL_OR         reduce using rule 56 (term -> factor .)
    RPARENTHESIS    reduce using rule 56 (term -> factor .)
    COMMA           reduce using rule 56 (term -> factor .)
    RSQUARE_BRACKET reduce using rule 56 (term -> factor .)
    TIMES           shift and go to state 100
    DIVIDE          shift and go to state 101

    arithmetic_l2                  shift and go to state 99

state 61

    (58) factor -> LPARENTHESIS . expression RPARENTHESIS
    (45) expression -> . exp_or
    (46) expression -> . expression logical_or exp_or
    (47) exp_or -> . exp_and
    (48) exp_or -> . exp_or logical_and exp_and
    (49) exp_and -> . exp_not
    (50) exp_and -> . exp_and logical_not exp_not
    (51) exp_not -> . exp
    (52) exp_not -> . exp relational_l1 term
    (53) exp_not -> . exp relational_l2 term
    (54) exp -> . term
    (55) exp -> . term arithmetic_l1 exp
    (56) term -> . factor
    (57) term -> . factor arithmetic_l2 term
    (58) factor -> . LPARENTHESIS expression RPARENTHESIS
    (59) factor -> . const_var
    (60) factor -> . function_call
    (61) factor -> . var
    (75) const_var -> . CONST_INT
    (76) const_var -> . CONST_FLOAT
    (77) const_var -> . CONST_STRING
    (36) function_call -> . ID LPARENTHESIS fun_param RPARENTHESIS
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    LPARENTHESIS    shift and go to state 61
    CONST_INT       shift and go to state 65
    CONST_FLOAT     shift and go to state 66
    CONST_STRING    shift and go to state 67
    ID              shift and go to state 42

    expression                     shift and go to state 102
    exp_or                         shift and go to state 55
    exp_and                        shift and go to state 56
    exp_not                        shift and go to state 57
    exp                            shift and go to state 58
    term                           shift and go to state 59
    factor                         shift and go to state 60
    const_var                      shift and go to state 62
    function_call                  shift and go to state 63
    var                            shift and go to state 64

state 62

    (59) factor -> const_var .

    TIMES           reduce using rule 59 (factor -> const_var .)
    DIVIDE          reduce using rule 59 (factor -> const_var .)
    PLUS            reduce using rule 59 (factor -> const_var .)
    MINUS           reduce using rule 59 (factor -> const_var .)
    EQUALS          reduce using rule 59 (factor -> const_var .)
    NOT_EQUALS      reduce using rule 59 (factor -> const_var .)
    LT              reduce using rule 59 (factor -> const_var .)
    GT              reduce using rule 59 (factor -> const_var .)
    LTE             reduce using rule 59 (factor -> const_var .)
    GTE             reduce using rule 59 (factor -> const_var .)
    BOOL_NOT        reduce using rule 59 (factor -> const_var .)
    BOOL_AND        reduce using rule 59 (factor -> const_var .)
    SEMICOLON       reduce using rule 59 (factor -> const_var .)
    BOOL_OR         reduce using rule 59 (factor -> const_var .)
    RPARENTHESIS    reduce using rule 59 (factor -> const_var .)
    COMMA           reduce using rule 59 (factor -> const_var .)
    RSQUARE_BRACKET reduce using rule 59 (factor -> const_var .)


state 63

    (60) factor -> function_call .

    TIMES           reduce using rule 60 (factor -> function_call .)
    DIVIDE          reduce using rule 60 (factor -> function_call .)
    PLUS            reduce using rule 60 (factor -> function_call .)
    MINUS           reduce using rule 60 (factor -> function_call .)
    EQUALS          reduce using rule 60 (factor -> function_call .)
    NOT_EQUALS      reduce using rule 60 (factor -> function_call .)
    LT              reduce using rule 60 (factor -> function_call .)
    GT              reduce using rule 60 (factor -> function_call .)
    LTE             reduce using rule 60 (factor -> function_call .)
    GTE             reduce using rule 60 (factor -> function_call .)
    BOOL_NOT        reduce using rule 60 (factor -> function_call .)
    BOOL_AND        reduce using rule 60 (factor -> function_call .)
    SEMICOLON       reduce using rule 60 (factor -> function_call .)
    BOOL_OR         reduce using rule 60 (factor -> function_call .)
    RPARENTHESIS    reduce using rule 60 (factor -> function_call .)
    COMMA           reduce using rule 60 (factor -> function_call .)
    RSQUARE_BRACKET reduce using rule 60 (factor -> function_call .)


state 64

    (61) factor -> var .

    TIMES           reduce using rule 61 (factor -> var .)
    DIVIDE          reduce using rule 61 (factor -> var .)
    PLUS            reduce using rule 61 (factor -> var .)
    MINUS           reduce using rule 61 (factor -> var .)
    EQUALS          reduce using rule 61 (factor -> var .)
    NOT_EQUALS      reduce using rule 61 (factor -> var .)
    LT              reduce using rule 61 (factor -> var .)
    GT              reduce using rule 61 (factor -> var .)
    LTE             reduce using rule 61 (factor -> var .)
    GTE             reduce using rule 61 (factor -> var .)
    BOOL_NOT        reduce using rule 61 (factor -> var .)
    BOOL_AND        reduce using rule 61 (factor -> var .)
    SEMICOLON       reduce using rule 61 (factor -> var .)
    BOOL_OR         reduce using rule 61 (factor -> var .)
    RPARENTHESIS    reduce using rule 61 (factor -> var .)
    COMMA           reduce using rule 61 (factor -> var .)
    RSQUARE_BRACKET reduce using rule 61 (factor -> var .)


state 65

    (75) const_var -> CONST_INT .

    TIMES           reduce using rule 75 (const_var -> CONST_INT .)
    DIVIDE          reduce using rule 75 (const_var -> CONST_INT .)
    PLUS            reduce using rule 75 (const_var -> CONST_INT .)
    MINUS           reduce using rule 75 (const_var -> CONST_INT .)
    EQUALS          reduce using rule 75 (const_var -> CONST_INT .)
    NOT_EQUALS      reduce using rule 75 (const_var -> CONST_INT .)
    LT              reduce using rule 75 (const_var -> CONST_INT .)
    GT              reduce using rule 75 (const_var -> CONST_INT .)
    LTE             reduce using rule 75 (const_var -> CONST_INT .)
    GTE             reduce using rule 75 (const_var -> CONST_INT .)
    BOOL_NOT        reduce using rule 75 (const_var -> CONST_INT .)
    BOOL_AND        reduce using rule 75 (const_var -> CONST_INT .)
    SEMICOLON       reduce using rule 75 (const_var -> CONST_INT .)
    BOOL_OR         reduce using rule 75 (const_var -> CONST_INT .)
    RPARENTHESIS    reduce using rule 75 (const_var -> CONST_INT .)
    COMMA           reduce using rule 75 (const_var -> CONST_INT .)
    RSQUARE_BRACKET reduce using rule 75 (const_var -> CONST_INT .)


state 66

    (76) const_var -> CONST_FLOAT .

    TIMES           reduce using rule 76 (const_var -> CONST_FLOAT .)
    DIVIDE          reduce using rule 76 (const_var -> CONST_FLOAT .)
    PLUS            reduce using rule 76 (const_var -> CONST_FLOAT .)
    MINUS           reduce using rule 76 (const_var -> CONST_FLOAT .)
    EQUALS          reduce using rule 76 (const_var -> CONST_FLOAT .)
    NOT_EQUALS      reduce using rule 76 (const_var -> CONST_FLOAT .)
    LT              reduce using rule 76 (const_var -> CONST_FLOAT .)
    GT              reduce using rule 76 (const_var -> CONST_FLOAT .)
    LTE             reduce using rule 76 (const_var -> CONST_FLOAT .)
    GTE             reduce using rule 76 (const_var -> CONST_FLOAT .)
    BOOL_NOT        reduce using rule 76 (const_var -> CONST_FLOAT .)
    BOOL_AND        reduce using rule 76 (const_var -> CONST_FLOAT .)
    SEMICOLON       reduce using rule 76 (const_var -> CONST_FLOAT .)
    BOOL_OR         reduce using rule 76 (const_var -> CONST_FLOAT .)
    RPARENTHESIS    reduce using rule 76 (const_var -> CONST_FLOAT .)
    COMMA           reduce using rule 76 (const_var -> CONST_FLOAT .)
    RSQUARE_BRACKET reduce using rule 76 (const_var -> CONST_FLOAT .)


state 67

    (77) const_var -> CONST_STRING .

    TIMES           reduce using rule 77 (const_var -> CONST_STRING .)
    DIVIDE          reduce using rule 77 (const_var -> CONST_STRING .)
    PLUS            reduce using rule 77 (const_var -> CONST_STRING .)
    MINUS           reduce using rule 77 (const_var -> CONST_STRING .)
    EQUALS          reduce using rule 77 (const_var -> CONST_STRING .)
    NOT_EQUALS      reduce using rule 77 (const_var -> CONST_STRING .)
    LT              reduce using rule 77 (const_var -> CONST_STRING .)
    GT              reduce using rule 77 (const_var -> CONST_STRING .)
    LTE             reduce using rule 77 (const_var -> CONST_STRING .)
    GTE             reduce using rule 77 (const_var -> CONST_STRING .)
    BOOL_NOT        reduce using rule 77 (const_var -> CONST_STRING .)
    BOOL_AND        reduce using rule 77 (const_var -> CONST_STRING .)
    SEMICOLON       reduce using rule 77 (const_var -> CONST_STRING .)
    BOOL_OR         reduce using rule 77 (const_var -> CONST_STRING .)
    RPARENTHESIS    reduce using rule 77 (const_var -> CONST_STRING .)
    COMMA           reduce using rule 77 (const_var -> CONST_STRING .)
    RSQUARE_BRACKET reduce using rule 77 (const_var -> CONST_STRING .)


state 68

    (26) assignment -> var ASSIGN . expression
    (45) expression -> . exp_or
    (46) expression -> . expression logical_or exp_or
    (47) exp_or -> . exp_and
    (48) exp_or -> . exp_or logical_and exp_and
    (49) exp_and -> . exp_not
    (50) exp_and -> . exp_and logical_not exp_not
    (51) exp_not -> . exp
    (52) exp_not -> . exp relational_l1 term
    (53) exp_not -> . exp relational_l2 term
    (54) exp -> . term
    (55) exp -> . term arithmetic_l1 exp
    (56) term -> . factor
    (57) term -> . factor arithmetic_l2 term
    (58) factor -> . LPARENTHESIS expression RPARENTHESIS
    (59) factor -> . const_var
    (60) factor -> . function_call
    (61) factor -> . var
    (75) const_var -> . CONST_INT
    (76) const_var -> . CONST_FLOAT
    (77) const_var -> . CONST_STRING
    (36) function_call -> . ID LPARENTHESIS fun_param RPARENTHESIS
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    LPARENTHESIS    shift and go to state 61
    CONST_INT       shift and go to state 65
    CONST_FLOAT     shift and go to state 66
    CONST_STRING    shift and go to state 67
    ID              shift and go to state 42

    var                            shift and go to state 64
    expression                     shift and go to state 103
    exp_or                         shift and go to state 55
    exp_and                        shift and go to state 56
    exp_not                        shift and go to state 57
    exp                            shift and go to state 58
    term                           shift and go to state 59
    factor                         shift and go to state 60
    const_var                      shift and go to state 62
    function_call                  shift and go to state 63

state 69

    (27) condition -> IF LPARENTHESIS . expression RPARENTHESIS block condition_else
    (45) expression -> . exp_or
    (46) expression -> . expression logical_or exp_or
    (47) exp_or -> . exp_and
    (48) exp_or -> . exp_or logical_and exp_and
    (49) exp_and -> . exp_not
    (50) exp_and -> . exp_and logical_not exp_not
    (51) exp_not -> . exp
    (52) exp_not -> . exp relational_l1 term
    (53) exp_not -> . exp relational_l2 term
    (54) exp -> . term
    (55) exp -> . term arithmetic_l1 exp
    (56) term -> . factor
    (57) term -> . factor arithmetic_l2 term
    (58) factor -> . LPARENTHESIS expression RPARENTHESIS
    (59) factor -> . const_var
    (60) factor -> . function_call
    (61) factor -> . var
    (75) const_var -> . CONST_INT
    (76) const_var -> . CONST_FLOAT
    (77) const_var -> . CONST_STRING
    (36) function_call -> . ID LPARENTHESIS fun_param RPARENTHESIS
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    LPARENTHESIS    shift and go to state 61
    CONST_INT       shift and go to state 65
    CONST_FLOAT     shift and go to state 66
    CONST_STRING    shift and go to state 67
    ID              shift and go to state 42

    expression                     shift and go to state 104
    exp_or                         shift and go to state 55
    exp_and                        shift and go to state 56
    exp_not                        shift and go to state 57
    exp                            shift and go to state 58
    term                           shift and go to state 59
    factor                         shift and go to state 60
    const_var                      shift and go to state 62
    function_call                  shift and go to state 63
    var                            shift and go to state 64

state 70

    (30) while_loop -> WHILE LPARENTHESIS . expression RPARENTHESIS block
    (45) expression -> . exp_or
    (46) expression -> . expression logical_or exp_or
    (47) exp_or -> . exp_and
    (48) exp_or -> . exp_or logical_and exp_and
    (49) exp_and -> . exp_not
    (50) exp_and -> . exp_and logical_not exp_not
    (51) exp_not -> . exp
    (52) exp_not -> . exp relational_l1 term
    (53) exp_not -> . exp relational_l2 term
    (54) exp -> . term
    (55) exp -> . term arithmetic_l1 exp
    (56) term -> . factor
    (57) term -> . factor arithmetic_l2 term
    (58) factor -> . LPARENTHESIS expression RPARENTHESIS
    (59) factor -> . const_var
    (60) factor -> . function_call
    (61) factor -> . var
    (75) const_var -> . CONST_INT
    (76) const_var -> . CONST_FLOAT
    (77) const_var -> . CONST_STRING
    (36) function_call -> . ID LPARENTHESIS fun_param RPARENTHESIS
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    LPARENTHESIS    shift and go to state 61
    CONST_INT       shift and go to state 65
    CONST_FLOAT     shift and go to state 66
    CONST_STRING    shift and go to state 67
    ID              shift and go to state 42

    expression                     shift and go to state 105
    exp_or                         shift and go to state 55
    exp_and                        shift and go to state 56
    exp_not                        shift and go to state 57
    exp                            shift and go to state 58
    term                           shift and go to state 59
    factor                         shift and go to state 60
    const_var                      shift and go to state 62
    function_call                  shift and go to state 63
    var                            shift and go to state 64

state 71

    (31) while_loop -> DO block . WHILE LPARENTHESIS expression RPARENTHESIS SEMICOLON

    WHILE           shift and go to state 106


state 72

    (32) for_loop -> FOR LPARENTHESIS . for_param1 for_param2 for_param3 RPARENTHESIS block
    (33) for_param1 -> . assignment SEMICOLON
    (26) assignment -> . var ASSIGN expression
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    ID              shift and go to state 109

    for_param1                     shift and go to state 107
    assignment                     shift and go to state 108
    var                            shift and go to state 37

state 73

    (36) function_call -> ID LPARENTHESIS . fun_param RPARENTHESIS
    (37) fun_param -> . expression COMMA fun_param
    (38) fun_param -> . expression
    (45) expression -> . exp_or
    (46) expression -> . expression logical_or exp_or
    (47) exp_or -> . exp_and
    (48) exp_or -> . exp_or logical_and exp_and
    (49) exp_and -> . exp_not
    (50) exp_and -> . exp_and logical_not exp_not
    (51) exp_not -> . exp
    (52) exp_not -> . exp relational_l1 term
    (53) exp_not -> . exp relational_l2 term
    (54) exp -> . term
    (55) exp -> . term arithmetic_l1 exp
    (56) term -> . factor
    (57) term -> . factor arithmetic_l2 term
    (58) factor -> . LPARENTHESIS expression RPARENTHESIS
    (59) factor -> . const_var
    (60) factor -> . function_call
    (61) factor -> . var
    (75) const_var -> . CONST_INT
    (76) const_var -> . CONST_FLOAT
    (77) const_var -> . CONST_STRING
    (36) function_call -> . ID LPARENTHESIS fun_param RPARENTHESIS
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    LPARENTHESIS    shift and go to state 61
    CONST_INT       shift and go to state 65
    CONST_FLOAT     shift and go to state 66
    CONST_STRING    shift and go to state 67
    ID              shift and go to state 42

    fun_param                      shift and go to state 110
    expression                     shift and go to state 111
    exp_or                         shift and go to state 55
    exp_and                        shift and go to state 56
    exp_not                        shift and go to state 57
    exp                            shift and go to state 58
    term                           shift and go to state 59
    factor                         shift and go to state 60
    const_var                      shift and go to state 62
    function_call                  shift and go to state 63
    var                            shift and go to state 64

state 74

    (79) var -> ID LSQUARE_BRACKET . expression RSQUARE_BRACKET
    (80) var -> ID LSQUARE_BRACKET . expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET
    (45) expression -> . exp_or
    (46) expression -> . expression logical_or exp_or
    (47) exp_or -> . exp_and
    (48) exp_or -> . exp_or logical_and exp_and
    (49) exp_and -> . exp_not
    (50) exp_and -> . exp_and logical_not exp_not
    (51) exp_not -> . exp
    (52) exp_not -> . exp relational_l1 term
    (53) exp_not -> . exp relational_l2 term
    (54) exp -> . term
    (55) exp -> . term arithmetic_l1 exp
    (56) term -> . factor
    (57) term -> . factor arithmetic_l2 term
    (58) factor -> . LPARENTHESIS expression RPARENTHESIS
    (59) factor -> . const_var
    (60) factor -> . function_call
    (61) factor -> . var
    (75) const_var -> . CONST_INT
    (76) const_var -> . CONST_FLOAT
    (77) const_var -> . CONST_STRING
    (36) function_call -> . ID LPARENTHESIS fun_param RPARENTHESIS
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    LPARENTHESIS    shift and go to state 61
    CONST_INT       shift and go to state 65
    CONST_FLOAT     shift and go to state 66
    CONST_STRING    shift and go to state 67
    ID              shift and go to state 42

    expression                     shift and go to state 112
    exp_or                         shift and go to state 55
    exp_and                        shift and go to state 56
    exp_not                        shift and go to state 57
    exp                            shift and go to state 58
    term                           shift and go to state 59
    factor                         shift and go to state 60
    const_var                      shift and go to state 62
    function_call                  shift and go to state 63
    var                            shift and go to state 64

state 75

    (39) write_function -> PRINT LPARENTHESIS . write RPARENTHESIS SEMICOLON
    (40) write -> . expression COMMA write
    (41) write -> . expression
    (45) expression -> . exp_or
    (46) expression -> . expression logical_or exp_or
    (47) exp_or -> . exp_and
    (48) exp_or -> . exp_or logical_and exp_and
    (49) exp_and -> . exp_not
    (50) exp_and -> . exp_and logical_not exp_not
    (51) exp_not -> . exp
    (52) exp_not -> . exp relational_l1 term
    (53) exp_not -> . exp relational_l2 term
    (54) exp -> . term
    (55) exp -> . term arithmetic_l1 exp
    (56) term -> . factor
    (57) term -> . factor arithmetic_l2 term
    (58) factor -> . LPARENTHESIS expression RPARENTHESIS
    (59) factor -> . const_var
    (60) factor -> . function_call
    (61) factor -> . var
    (75) const_var -> . CONST_INT
    (76) const_var -> . CONST_FLOAT
    (77) const_var -> . CONST_STRING
    (36) function_call -> . ID LPARENTHESIS fun_param RPARENTHESIS
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    LPARENTHESIS    shift and go to state 61
    CONST_INT       shift and go to state 65
    CONST_FLOAT     shift and go to state 66
    CONST_STRING    shift and go to state 67
    ID              shift and go to state 42

    write                          shift and go to state 113
    expression                     shift and go to state 114
    exp_or                         shift and go to state 55
    exp_and                        shift and go to state 56
    exp_not                        shift and go to state 57
    exp                            shift and go to state 58
    term                           shift and go to state 59
    factor                         shift and go to state 60
    const_var                      shift and go to state 62
    function_call                  shift and go to state 63
    var                            shift and go to state 64

state 76

    (42) read_function -> READ LPARENTHESIS . read RPARENTHESIS SEMICOLON
    (43) read -> . expression COMMA read
    (44) read -> . expression
    (45) expression -> . exp_or
    (46) expression -> . expression logical_or exp_or
    (47) exp_or -> . exp_and
    (48) exp_or -> . exp_or logical_and exp_and
    (49) exp_and -> . exp_not
    (50) exp_and -> . exp_and logical_not exp_not
    (51) exp_not -> . exp
    (52) exp_not -> . exp relational_l1 term
    (53) exp_not -> . exp relational_l2 term
    (54) exp -> . term
    (55) exp -> . term arithmetic_l1 exp
    (56) term -> . factor
    (57) term -> . factor arithmetic_l2 term
    (58) factor -> . LPARENTHESIS expression RPARENTHESIS
    (59) factor -> . const_var
    (60) factor -> . function_call
    (61) factor -> . var
    (75) const_var -> . CONST_INT
    (76) const_var -> . CONST_FLOAT
    (77) const_var -> . CONST_STRING
    (36) function_call -> . ID LPARENTHESIS fun_param RPARENTHESIS
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    LPARENTHESIS    shift and go to state 61
    CONST_INT       shift and go to state 65
    CONST_FLOAT     shift and go to state 66
    CONST_STRING    shift and go to state 67
    ID              shift and go to state 42

    read                           shift and go to state 115
    expression                     shift and go to state 116
    exp_or                         shift and go to state 55
    exp_and                        shift and go to state 56
    exp_not                        shift and go to state 57
    exp                            shift and go to state 58
    term                           shift and go to state 59
    factor                         shift and go to state 60
    const_var                      shift and go to state 62
    function_call                  shift and go to state 63
    var                            shift and go to state 64

state 77

    (2) functions -> DEF type_fun ID LPARENTHESIS param . RPARENTHESIS block functions

    RPARENTHESIS    shift and go to state 117


state 78

    (4) param -> type . ID COMMA param
    (5) param -> type . ID

    ID              shift and go to state 118


state 79

    (6) param -> empty .

    RPARENTHESIS    reduce using rule 6 (param -> empty .)


state 80

    (24) vars_n -> ID LSQUARE_BRACKET CONST_INT RSQUARE_BRACKET .
    (25) vars_n -> ID LSQUARE_BRACKET CONST_INT RSQUARE_BRACKET . LSQUARE_BRACKET CONST_INT RSQUARE_BRACKET

    SEMICOLON       reduce using rule 24 (vars_n -> ID LSQUARE_BRACKET CONST_INT RSQUARE_BRACKET .)
    LSQUARE_BRACKET shift and go to state 119


state 81

    (17) statment -> RETURN expression SEMICOLON .

    RETURN          reduce using rule 17 (statment -> RETURN expression SEMICOLON .)
    VAR             reduce using rule 17 (statment -> RETURN expression SEMICOLON .)
    IF              reduce using rule 17 (statment -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 17 (statment -> RETURN expression SEMICOLON .)
    DO              reduce using rule 17 (statment -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 17 (statment -> RETURN expression SEMICOLON .)
    ID              reduce using rule 17 (statment -> RETURN expression SEMICOLON .)
    PRINT           reduce using rule 17 (statment -> RETURN expression SEMICOLON .)
    READ            reduce using rule 17 (statment -> RETURN expression SEMICOLON .)
    RCURLY_BRACKET  reduce using rule 17 (statment -> RETURN expression SEMICOLON .)


state 82

    (46) expression -> expression logical_or . exp_or
    (47) exp_or -> . exp_and
    (48) exp_or -> . exp_or logical_and exp_and
    (49) exp_and -> . exp_not
    (50) exp_and -> . exp_and logical_not exp_not
    (51) exp_not -> . exp
    (52) exp_not -> . exp relational_l1 term
    (53) exp_not -> . exp relational_l2 term
    (54) exp -> . term
    (55) exp -> . term arithmetic_l1 exp
    (56) term -> . factor
    (57) term -> . factor arithmetic_l2 term
    (58) factor -> . LPARENTHESIS expression RPARENTHESIS
    (59) factor -> . const_var
    (60) factor -> . function_call
    (61) factor -> . var
    (75) const_var -> . CONST_INT
    (76) const_var -> . CONST_FLOAT
    (77) const_var -> . CONST_STRING
    (36) function_call -> . ID LPARENTHESIS fun_param RPARENTHESIS
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    LPARENTHESIS    shift and go to state 61
    CONST_INT       shift and go to state 65
    CONST_FLOAT     shift and go to state 66
    CONST_STRING    shift and go to state 67
    ID              shift and go to state 42

    exp_or                         shift and go to state 120
    exp_and                        shift and go to state 56
    exp_not                        shift and go to state 57
    exp                            shift and go to state 58
    term                           shift and go to state 59
    factor                         shift and go to state 60
    const_var                      shift and go to state 62
    function_call                  shift and go to state 63
    var                            shift and go to state 64

state 83

    (72) logical_or -> BOOL_OR .

    LPARENTHESIS    reduce using rule 72 (logical_or -> BOOL_OR .)
    CONST_INT       reduce using rule 72 (logical_or -> BOOL_OR .)
    CONST_FLOAT     reduce using rule 72 (logical_or -> BOOL_OR .)
    CONST_STRING    reduce using rule 72 (logical_or -> BOOL_OR .)
    ID              reduce using rule 72 (logical_or -> BOOL_OR .)


state 84

    (48) exp_or -> exp_or logical_and . exp_and
    (49) exp_and -> . exp_not
    (50) exp_and -> . exp_and logical_not exp_not
    (51) exp_not -> . exp
    (52) exp_not -> . exp relational_l1 term
    (53) exp_not -> . exp relational_l2 term
    (54) exp -> . term
    (55) exp -> . term arithmetic_l1 exp
    (56) term -> . factor
    (57) term -> . factor arithmetic_l2 term
    (58) factor -> . LPARENTHESIS expression RPARENTHESIS
    (59) factor -> . const_var
    (60) factor -> . function_call
    (61) factor -> . var
    (75) const_var -> . CONST_INT
    (76) const_var -> . CONST_FLOAT
    (77) const_var -> . CONST_STRING
    (36) function_call -> . ID LPARENTHESIS fun_param RPARENTHESIS
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    LPARENTHESIS    shift and go to state 61
    CONST_INT       shift and go to state 65
    CONST_FLOAT     shift and go to state 66
    CONST_STRING    shift and go to state 67
    ID              shift and go to state 42

    exp_and                        shift and go to state 121
    exp_not                        shift and go to state 57
    exp                            shift and go to state 58
    term                           shift and go to state 59
    factor                         shift and go to state 60
    const_var                      shift and go to state 62
    function_call                  shift and go to state 63
    var                            shift and go to state 64

state 85

    (73) logical_and -> BOOL_AND .

    LPARENTHESIS    reduce using rule 73 (logical_and -> BOOL_AND .)
    CONST_INT       reduce using rule 73 (logical_and -> BOOL_AND .)
    CONST_FLOAT     reduce using rule 73 (logical_and -> BOOL_AND .)
    CONST_STRING    reduce using rule 73 (logical_and -> BOOL_AND .)
    ID              reduce using rule 73 (logical_and -> BOOL_AND .)


state 86

    (50) exp_and -> exp_and logical_not . exp_not
    (51) exp_not -> . exp
    (52) exp_not -> . exp relational_l1 term
    (53) exp_not -> . exp relational_l2 term
    (54) exp -> . term
    (55) exp -> . term arithmetic_l1 exp
    (56) term -> . factor
    (57) term -> . factor arithmetic_l2 term
    (58) factor -> . LPARENTHESIS expression RPARENTHESIS
    (59) factor -> . const_var
    (60) factor -> . function_call
    (61) factor -> . var
    (75) const_var -> . CONST_INT
    (76) const_var -> . CONST_FLOAT
    (77) const_var -> . CONST_STRING
    (36) function_call -> . ID LPARENTHESIS fun_param RPARENTHESIS
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    LPARENTHESIS    shift and go to state 61
    CONST_INT       shift and go to state 65
    CONST_FLOAT     shift and go to state 66
    CONST_STRING    shift and go to state 67
    ID              shift and go to state 42

    exp_not                        shift and go to state 122
    exp                            shift and go to state 58
    term                           shift and go to state 59
    factor                         shift and go to state 60
    const_var                      shift and go to state 62
    function_call                  shift and go to state 63
    var                            shift and go to state 64

state 87

    (74) logical_not -> BOOL_NOT .

    LPARENTHESIS    reduce using rule 74 (logical_not -> BOOL_NOT .)
    CONST_INT       reduce using rule 74 (logical_not -> BOOL_NOT .)
    CONST_FLOAT     reduce using rule 74 (logical_not -> BOOL_NOT .)
    CONST_STRING    reduce using rule 74 (logical_not -> BOOL_NOT .)
    ID              reduce using rule 74 (logical_not -> BOOL_NOT .)


state 88

    (52) exp_not -> exp relational_l1 . term
    (56) term -> . factor
    (57) term -> . factor arithmetic_l2 term
    (58) factor -> . LPARENTHESIS expression RPARENTHESIS
    (59) factor -> . const_var
    (60) factor -> . function_call
    (61) factor -> . var
    (75) const_var -> . CONST_INT
    (76) const_var -> . CONST_FLOAT
    (77) const_var -> . CONST_STRING
    (36) function_call -> . ID LPARENTHESIS fun_param RPARENTHESIS
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    LPARENTHESIS    shift and go to state 61
    CONST_INT       shift and go to state 65
    CONST_FLOAT     shift and go to state 66
    CONST_STRING    shift and go to state 67
    ID              shift and go to state 42

    term                           shift and go to state 123
    factor                         shift and go to state 60
    const_var                      shift and go to state 62
    function_call                  shift and go to state 63
    var                            shift and go to state 64

state 89

    (53) exp_not -> exp relational_l2 . term
    (56) term -> . factor
    (57) term -> . factor arithmetic_l2 term
    (58) factor -> . LPARENTHESIS expression RPARENTHESIS
    (59) factor -> . const_var
    (60) factor -> . function_call
    (61) factor -> . var
    (75) const_var -> . CONST_INT
    (76) const_var -> . CONST_FLOAT
    (77) const_var -> . CONST_STRING
    (36) function_call -> . ID LPARENTHESIS fun_param RPARENTHESIS
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    LPARENTHESIS    shift and go to state 61
    CONST_INT       shift and go to state 65
    CONST_FLOAT     shift and go to state 66
    CONST_STRING    shift and go to state 67
    ID              shift and go to state 42

    term                           shift and go to state 124
    factor                         shift and go to state 60
    const_var                      shift and go to state 62
    function_call                  shift and go to state 63
    var                            shift and go to state 64

state 90

    (66) relational_l1 -> EQUALS .

    LPARENTHESIS    reduce using rule 66 (relational_l1 -> EQUALS .)
    CONST_INT       reduce using rule 66 (relational_l1 -> EQUALS .)
    CONST_FLOAT     reduce using rule 66 (relational_l1 -> EQUALS .)
    CONST_STRING    reduce using rule 66 (relational_l1 -> EQUALS .)
    ID              reduce using rule 66 (relational_l1 -> EQUALS .)


state 91

    (67) relational_l1 -> NOT_EQUALS .

    LPARENTHESIS    reduce using rule 67 (relational_l1 -> NOT_EQUALS .)
    CONST_INT       reduce using rule 67 (relational_l1 -> NOT_EQUALS .)
    CONST_FLOAT     reduce using rule 67 (relational_l1 -> NOT_EQUALS .)
    CONST_STRING    reduce using rule 67 (relational_l1 -> NOT_EQUALS .)
    ID              reduce using rule 67 (relational_l1 -> NOT_EQUALS .)


state 92

    (68) relational_l2 -> LT .

    LPARENTHESIS    reduce using rule 68 (relational_l2 -> LT .)
    CONST_INT       reduce using rule 68 (relational_l2 -> LT .)
    CONST_FLOAT     reduce using rule 68 (relational_l2 -> LT .)
    CONST_STRING    reduce using rule 68 (relational_l2 -> LT .)
    ID              reduce using rule 68 (relational_l2 -> LT .)


state 93

    (69) relational_l2 -> GT .

    LPARENTHESIS    reduce using rule 69 (relational_l2 -> GT .)
    CONST_INT       reduce using rule 69 (relational_l2 -> GT .)
    CONST_FLOAT     reduce using rule 69 (relational_l2 -> GT .)
    CONST_STRING    reduce using rule 69 (relational_l2 -> GT .)
    ID              reduce using rule 69 (relational_l2 -> GT .)


state 94

    (70) relational_l2 -> LTE .

    LPARENTHESIS    reduce using rule 70 (relational_l2 -> LTE .)
    CONST_INT       reduce using rule 70 (relational_l2 -> LTE .)
    CONST_FLOAT     reduce using rule 70 (relational_l2 -> LTE .)
    CONST_STRING    reduce using rule 70 (relational_l2 -> LTE .)
    ID              reduce using rule 70 (relational_l2 -> LTE .)


state 95

    (71) relational_l2 -> GTE .

    LPARENTHESIS    reduce using rule 71 (relational_l2 -> GTE .)
    CONST_INT       reduce using rule 71 (relational_l2 -> GTE .)
    CONST_FLOAT     reduce using rule 71 (relational_l2 -> GTE .)
    CONST_STRING    reduce using rule 71 (relational_l2 -> GTE .)
    ID              reduce using rule 71 (relational_l2 -> GTE .)


state 96

    (55) exp -> term arithmetic_l1 . exp
    (54) exp -> . term
    (55) exp -> . term arithmetic_l1 exp
    (56) term -> . factor
    (57) term -> . factor arithmetic_l2 term
    (58) factor -> . LPARENTHESIS expression RPARENTHESIS
    (59) factor -> . const_var
    (60) factor -> . function_call
    (61) factor -> . var
    (75) const_var -> . CONST_INT
    (76) const_var -> . CONST_FLOAT
    (77) const_var -> . CONST_STRING
    (36) function_call -> . ID LPARENTHESIS fun_param RPARENTHESIS
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    LPARENTHESIS    shift and go to state 61
    CONST_INT       shift and go to state 65
    CONST_FLOAT     shift and go to state 66
    CONST_STRING    shift and go to state 67
    ID              shift and go to state 42

    term                           shift and go to state 59
    exp                            shift and go to state 125
    factor                         shift and go to state 60
    const_var                      shift and go to state 62
    function_call                  shift and go to state 63
    var                            shift and go to state 64

state 97

    (62) arithmetic_l1 -> PLUS .

    LPARENTHESIS    reduce using rule 62 (arithmetic_l1 -> PLUS .)
    CONST_INT       reduce using rule 62 (arithmetic_l1 -> PLUS .)
    CONST_FLOAT     reduce using rule 62 (arithmetic_l1 -> PLUS .)
    CONST_STRING    reduce using rule 62 (arithmetic_l1 -> PLUS .)
    ID              reduce using rule 62 (arithmetic_l1 -> PLUS .)


state 98

    (63) arithmetic_l1 -> MINUS .

    LPARENTHESIS    reduce using rule 63 (arithmetic_l1 -> MINUS .)
    CONST_INT       reduce using rule 63 (arithmetic_l1 -> MINUS .)
    CONST_FLOAT     reduce using rule 63 (arithmetic_l1 -> MINUS .)
    CONST_STRING    reduce using rule 63 (arithmetic_l1 -> MINUS .)
    ID              reduce using rule 63 (arithmetic_l1 -> MINUS .)


state 99

    (57) term -> factor arithmetic_l2 . term
    (56) term -> . factor
    (57) term -> . factor arithmetic_l2 term
    (58) factor -> . LPARENTHESIS expression RPARENTHESIS
    (59) factor -> . const_var
    (60) factor -> . function_call
    (61) factor -> . var
    (75) const_var -> . CONST_INT
    (76) const_var -> . CONST_FLOAT
    (77) const_var -> . CONST_STRING
    (36) function_call -> . ID LPARENTHESIS fun_param RPARENTHESIS
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    LPARENTHESIS    shift and go to state 61
    CONST_INT       shift and go to state 65
    CONST_FLOAT     shift and go to state 66
    CONST_STRING    shift and go to state 67
    ID              shift and go to state 42

    factor                         shift and go to state 60
    term                           shift and go to state 126
    const_var                      shift and go to state 62
    function_call                  shift and go to state 63
    var                            shift and go to state 64

state 100

    (64) arithmetic_l2 -> TIMES .

    LPARENTHESIS    reduce using rule 64 (arithmetic_l2 -> TIMES .)
    CONST_INT       reduce using rule 64 (arithmetic_l2 -> TIMES .)
    CONST_FLOAT     reduce using rule 64 (arithmetic_l2 -> TIMES .)
    CONST_STRING    reduce using rule 64 (arithmetic_l2 -> TIMES .)
    ID              reduce using rule 64 (arithmetic_l2 -> TIMES .)


state 101

    (65) arithmetic_l2 -> DIVIDE .

    LPARENTHESIS    reduce using rule 65 (arithmetic_l2 -> DIVIDE .)
    CONST_INT       reduce using rule 65 (arithmetic_l2 -> DIVIDE .)
    CONST_FLOAT     reduce using rule 65 (arithmetic_l2 -> DIVIDE .)
    CONST_STRING    reduce using rule 65 (arithmetic_l2 -> DIVIDE .)
    ID              reduce using rule 65 (arithmetic_l2 -> DIVIDE .)


state 102

    (58) factor -> LPARENTHESIS expression . RPARENTHESIS
    (46) expression -> expression . logical_or exp_or
    (72) logical_or -> . BOOL_OR

    RPARENTHESIS    shift and go to state 127
    BOOL_OR         shift and go to state 83

    logical_or                     shift and go to state 82

state 103

    (26) assignment -> var ASSIGN expression .
    (46) expression -> expression . logical_or exp_or
    (72) logical_or -> . BOOL_OR

    SEMICOLON       reduce using rule 26 (assignment -> var ASSIGN expression .)
    RPARENTHESIS    reduce using rule 26 (assignment -> var ASSIGN expression .)
    BOOL_OR         shift and go to state 83

    logical_or                     shift and go to state 82

state 104

    (27) condition -> IF LPARENTHESIS expression . RPARENTHESIS block condition_else
    (46) expression -> expression . logical_or exp_or
    (72) logical_or -> . BOOL_OR

    RPARENTHESIS    shift and go to state 128
    BOOL_OR         shift and go to state 83

    logical_or                     shift and go to state 82

state 105

    (30) while_loop -> WHILE LPARENTHESIS expression . RPARENTHESIS block
    (46) expression -> expression . logical_or exp_or
    (72) logical_or -> . BOOL_OR

    RPARENTHESIS    shift and go to state 129
    BOOL_OR         shift and go to state 83

    logical_or                     shift and go to state 82

state 106

    (31) while_loop -> DO block WHILE . LPARENTHESIS expression RPARENTHESIS SEMICOLON

    LPARENTHESIS    shift and go to state 130


state 107

    (32) for_loop -> FOR LPARENTHESIS for_param1 . for_param2 for_param3 RPARENTHESIS block
    (34) for_param2 -> . expression SEMICOLON
    (45) expression -> . exp_or
    (46) expression -> . expression logical_or exp_or
    (47) exp_or -> . exp_and
    (48) exp_or -> . exp_or logical_and exp_and
    (49) exp_and -> . exp_not
    (50) exp_and -> . exp_and logical_not exp_not
    (51) exp_not -> . exp
    (52) exp_not -> . exp relational_l1 term
    (53) exp_not -> . exp relational_l2 term
    (54) exp -> . term
    (55) exp -> . term arithmetic_l1 exp
    (56) term -> . factor
    (57) term -> . factor arithmetic_l2 term
    (58) factor -> . LPARENTHESIS expression RPARENTHESIS
    (59) factor -> . const_var
    (60) factor -> . function_call
    (61) factor -> . var
    (75) const_var -> . CONST_INT
    (76) const_var -> . CONST_FLOAT
    (77) const_var -> . CONST_STRING
    (36) function_call -> . ID LPARENTHESIS fun_param RPARENTHESIS
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    LPARENTHESIS    shift and go to state 61
    CONST_INT       shift and go to state 65
    CONST_FLOAT     shift and go to state 66
    CONST_STRING    shift and go to state 67
    ID              shift and go to state 42

    for_param2                     shift and go to state 131
    expression                     shift and go to state 132
    exp_or                         shift and go to state 55
    exp_and                        shift and go to state 56
    exp_not                        shift and go to state 57
    exp                            shift and go to state 58
    term                           shift and go to state 59
    factor                         shift and go to state 60
    const_var                      shift and go to state 62
    function_call                  shift and go to state 63
    var                            shift and go to state 64

state 108

    (33) for_param1 -> assignment . SEMICOLON

    SEMICOLON       shift and go to state 133


state 109

    (78) var -> ID .
    (79) var -> ID . LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> ID . LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    ASSIGN          reduce using rule 78 (var -> ID .)
    LSQUARE_BRACKET shift and go to state 74


state 110

    (36) function_call -> ID LPARENTHESIS fun_param . RPARENTHESIS

    RPARENTHESIS    shift and go to state 134


state 111

    (37) fun_param -> expression . COMMA fun_param
    (38) fun_param -> expression .
    (46) expression -> expression . logical_or exp_or
    (72) logical_or -> . BOOL_OR

    COMMA           shift and go to state 135
    RPARENTHESIS    reduce using rule 38 (fun_param -> expression .)
    BOOL_OR         shift and go to state 83

    logical_or                     shift and go to state 82

state 112

    (79) var -> ID LSQUARE_BRACKET expression . RSQUARE_BRACKET
    (80) var -> ID LSQUARE_BRACKET expression . RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET
    (46) expression -> expression . logical_or exp_or
    (72) logical_or -> . BOOL_OR

    RSQUARE_BRACKET shift and go to state 136
    BOOL_OR         shift and go to state 83

    logical_or                     shift and go to state 82

state 113

    (39) write_function -> PRINT LPARENTHESIS write . RPARENTHESIS SEMICOLON

    RPARENTHESIS    shift and go to state 137


state 114

    (40) write -> expression . COMMA write
    (41) write -> expression .
    (46) expression -> expression . logical_or exp_or
    (72) logical_or -> . BOOL_OR

    COMMA           shift and go to state 138
    RPARENTHESIS    reduce using rule 41 (write -> expression .)
    BOOL_OR         shift and go to state 83

    logical_or                     shift and go to state 82

state 115

    (42) read_function -> READ LPARENTHESIS read . RPARENTHESIS SEMICOLON

    RPARENTHESIS    shift and go to state 139


state 116

    (43) read -> expression . COMMA read
    (44) read -> expression .
    (46) expression -> expression . logical_or exp_or
    (72) logical_or -> . BOOL_OR

    COMMA           shift and go to state 140
    RPARENTHESIS    reduce using rule 44 (read -> expression .)
    BOOL_OR         shift and go to state 83

    logical_or                     shift and go to state 82

state 117

    (2) functions -> DEF type_fun ID LPARENTHESIS param RPARENTHESIS . block functions
    (7) block -> . LCURLY_BRACKET content_block RCURLY_BRACKET

    LCURLY_BRACKET  shift and go to state 20

    block                          shift and go to state 141

state 118

    (4) param -> type ID . COMMA param
    (5) param -> type ID .

    COMMA           shift and go to state 142
    RPARENTHESIS    reduce using rule 5 (param -> type ID .)


state 119

    (25) vars_n -> ID LSQUARE_BRACKET CONST_INT RSQUARE_BRACKET LSQUARE_BRACKET . CONST_INT RSQUARE_BRACKET

    CONST_INT       shift and go to state 143


state 120

    (46) expression -> expression logical_or exp_or .
    (48) exp_or -> exp_or . logical_and exp_and
    (73) logical_and -> . BOOL_AND

    SEMICOLON       reduce using rule 46 (expression -> expression logical_or exp_or .)
    BOOL_OR         reduce using rule 46 (expression -> expression logical_or exp_or .)
    RPARENTHESIS    reduce using rule 46 (expression -> expression logical_or exp_or .)
    COMMA           reduce using rule 46 (expression -> expression logical_or exp_or .)
    RSQUARE_BRACKET reduce using rule 46 (expression -> expression logical_or exp_or .)
    BOOL_AND        shift and go to state 85

    logical_and                    shift and go to state 84

state 121

    (48) exp_or -> exp_or logical_and exp_and .
    (50) exp_and -> exp_and . logical_not exp_not
    (74) logical_not -> . BOOL_NOT

    BOOL_AND        reduce using rule 48 (exp_or -> exp_or logical_and exp_and .)
    SEMICOLON       reduce using rule 48 (exp_or -> exp_or logical_and exp_and .)
    BOOL_OR         reduce using rule 48 (exp_or -> exp_or logical_and exp_and .)
    RPARENTHESIS    reduce using rule 48 (exp_or -> exp_or logical_and exp_and .)
    COMMA           reduce using rule 48 (exp_or -> exp_or logical_and exp_and .)
    RSQUARE_BRACKET reduce using rule 48 (exp_or -> exp_or logical_and exp_and .)
    BOOL_NOT        shift and go to state 87

    logical_not                    shift and go to state 86

state 122

    (50) exp_and -> exp_and logical_not exp_not .

    BOOL_NOT        reduce using rule 50 (exp_and -> exp_and logical_not exp_not .)
    BOOL_AND        reduce using rule 50 (exp_and -> exp_and logical_not exp_not .)
    SEMICOLON       reduce using rule 50 (exp_and -> exp_and logical_not exp_not .)
    BOOL_OR         reduce using rule 50 (exp_and -> exp_and logical_not exp_not .)
    RPARENTHESIS    reduce using rule 50 (exp_and -> exp_and logical_not exp_not .)
    COMMA           reduce using rule 50 (exp_and -> exp_and logical_not exp_not .)
    RSQUARE_BRACKET reduce using rule 50 (exp_and -> exp_and logical_not exp_not .)


state 123

    (52) exp_not -> exp relational_l1 term .

    BOOL_NOT        reduce using rule 52 (exp_not -> exp relational_l1 term .)
    BOOL_AND        reduce using rule 52 (exp_not -> exp relational_l1 term .)
    SEMICOLON       reduce using rule 52 (exp_not -> exp relational_l1 term .)
    BOOL_OR         reduce using rule 52 (exp_not -> exp relational_l1 term .)
    RPARENTHESIS    reduce using rule 52 (exp_not -> exp relational_l1 term .)
    COMMA           reduce using rule 52 (exp_not -> exp relational_l1 term .)
    RSQUARE_BRACKET reduce using rule 52 (exp_not -> exp relational_l1 term .)


state 124

    (53) exp_not -> exp relational_l2 term .

    BOOL_NOT        reduce using rule 53 (exp_not -> exp relational_l2 term .)
    BOOL_AND        reduce using rule 53 (exp_not -> exp relational_l2 term .)
    SEMICOLON       reduce using rule 53 (exp_not -> exp relational_l2 term .)
    BOOL_OR         reduce using rule 53 (exp_not -> exp relational_l2 term .)
    RPARENTHESIS    reduce using rule 53 (exp_not -> exp relational_l2 term .)
    COMMA           reduce using rule 53 (exp_not -> exp relational_l2 term .)
    RSQUARE_BRACKET reduce using rule 53 (exp_not -> exp relational_l2 term .)


state 125

    (55) exp -> term arithmetic_l1 exp .

    EQUALS          reduce using rule 55 (exp -> term arithmetic_l1 exp .)
    NOT_EQUALS      reduce using rule 55 (exp -> term arithmetic_l1 exp .)
    LT              reduce using rule 55 (exp -> term arithmetic_l1 exp .)
    GT              reduce using rule 55 (exp -> term arithmetic_l1 exp .)
    LTE             reduce using rule 55 (exp -> term arithmetic_l1 exp .)
    GTE             reduce using rule 55 (exp -> term arithmetic_l1 exp .)
    BOOL_NOT        reduce using rule 55 (exp -> term arithmetic_l1 exp .)
    BOOL_AND        reduce using rule 55 (exp -> term arithmetic_l1 exp .)
    SEMICOLON       reduce using rule 55 (exp -> term arithmetic_l1 exp .)
    BOOL_OR         reduce using rule 55 (exp -> term arithmetic_l1 exp .)
    RPARENTHESIS    reduce using rule 55 (exp -> term arithmetic_l1 exp .)
    COMMA           reduce using rule 55 (exp -> term arithmetic_l1 exp .)
    RSQUARE_BRACKET reduce using rule 55 (exp -> term arithmetic_l1 exp .)


state 126

    (57) term -> factor arithmetic_l2 term .

    PLUS            reduce using rule 57 (term -> factor arithmetic_l2 term .)
    MINUS           reduce using rule 57 (term -> factor arithmetic_l2 term .)
    EQUALS          reduce using rule 57 (term -> factor arithmetic_l2 term .)
    NOT_EQUALS      reduce using rule 57 (term -> factor arithmetic_l2 term .)
    LT              reduce using rule 57 (term -> factor arithmetic_l2 term .)
    GT              reduce using rule 57 (term -> factor arithmetic_l2 term .)
    LTE             reduce using rule 57 (term -> factor arithmetic_l2 term .)
    GTE             reduce using rule 57 (term -> factor arithmetic_l2 term .)
    BOOL_NOT        reduce using rule 57 (term -> factor arithmetic_l2 term .)
    BOOL_AND        reduce using rule 57 (term -> factor arithmetic_l2 term .)
    SEMICOLON       reduce using rule 57 (term -> factor arithmetic_l2 term .)
    BOOL_OR         reduce using rule 57 (term -> factor arithmetic_l2 term .)
    RPARENTHESIS    reduce using rule 57 (term -> factor arithmetic_l2 term .)
    COMMA           reduce using rule 57 (term -> factor arithmetic_l2 term .)
    RSQUARE_BRACKET reduce using rule 57 (term -> factor arithmetic_l2 term .)


state 127

    (58) factor -> LPARENTHESIS expression RPARENTHESIS .

    TIMES           reduce using rule 58 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    DIVIDE          reduce using rule 58 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    PLUS            reduce using rule 58 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    MINUS           reduce using rule 58 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    EQUALS          reduce using rule 58 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    NOT_EQUALS      reduce using rule 58 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    LT              reduce using rule 58 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    GT              reduce using rule 58 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    LTE             reduce using rule 58 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    GTE             reduce using rule 58 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    BOOL_NOT        reduce using rule 58 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    BOOL_AND        reduce using rule 58 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    SEMICOLON       reduce using rule 58 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    BOOL_OR         reduce using rule 58 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    RPARENTHESIS    reduce using rule 58 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    COMMA           reduce using rule 58 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    RSQUARE_BRACKET reduce using rule 58 (factor -> LPARENTHESIS expression RPARENTHESIS .)


state 128

    (27) condition -> IF LPARENTHESIS expression RPARENTHESIS . block condition_else
    (7) block -> . LCURLY_BRACKET content_block RCURLY_BRACKET

    LCURLY_BRACKET  shift and go to state 20

    block                          shift and go to state 144

state 129

    (30) while_loop -> WHILE LPARENTHESIS expression RPARENTHESIS . block
    (7) block -> . LCURLY_BRACKET content_block RCURLY_BRACKET

    LCURLY_BRACKET  shift and go to state 20

    block                          shift and go to state 145

state 130

    (31) while_loop -> DO block WHILE LPARENTHESIS . expression RPARENTHESIS SEMICOLON
    (45) expression -> . exp_or
    (46) expression -> . expression logical_or exp_or
    (47) exp_or -> . exp_and
    (48) exp_or -> . exp_or logical_and exp_and
    (49) exp_and -> . exp_not
    (50) exp_and -> . exp_and logical_not exp_not
    (51) exp_not -> . exp
    (52) exp_not -> . exp relational_l1 term
    (53) exp_not -> . exp relational_l2 term
    (54) exp -> . term
    (55) exp -> . term arithmetic_l1 exp
    (56) term -> . factor
    (57) term -> . factor arithmetic_l2 term
    (58) factor -> . LPARENTHESIS expression RPARENTHESIS
    (59) factor -> . const_var
    (60) factor -> . function_call
    (61) factor -> . var
    (75) const_var -> . CONST_INT
    (76) const_var -> . CONST_FLOAT
    (77) const_var -> . CONST_STRING
    (36) function_call -> . ID LPARENTHESIS fun_param RPARENTHESIS
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    LPARENTHESIS    shift and go to state 61
    CONST_INT       shift and go to state 65
    CONST_FLOAT     shift and go to state 66
    CONST_STRING    shift and go to state 67
    ID              shift and go to state 42

    expression                     shift and go to state 146
    exp_or                         shift and go to state 55
    exp_and                        shift and go to state 56
    exp_not                        shift and go to state 57
    exp                            shift and go to state 58
    term                           shift and go to state 59
    factor                         shift and go to state 60
    const_var                      shift and go to state 62
    function_call                  shift and go to state 63
    var                            shift and go to state 64

state 131

    (32) for_loop -> FOR LPARENTHESIS for_param1 for_param2 . for_param3 RPARENTHESIS block
    (35) for_param3 -> . assignment
    (26) assignment -> . var ASSIGN expression
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    ID              shift and go to state 109

    for_param3                     shift and go to state 147
    assignment                     shift and go to state 148
    var                            shift and go to state 37

state 132

    (34) for_param2 -> expression . SEMICOLON
    (46) expression -> expression . logical_or exp_or
    (72) logical_or -> . BOOL_OR

    SEMICOLON       shift and go to state 149
    BOOL_OR         shift and go to state 83

    logical_or                     shift and go to state 82

state 133

    (33) for_param1 -> assignment SEMICOLON .

    LPARENTHESIS    reduce using rule 33 (for_param1 -> assignment SEMICOLON .)
    CONST_INT       reduce using rule 33 (for_param1 -> assignment SEMICOLON .)
    CONST_FLOAT     reduce using rule 33 (for_param1 -> assignment SEMICOLON .)
    CONST_STRING    reduce using rule 33 (for_param1 -> assignment SEMICOLON .)
    ID              reduce using rule 33 (for_param1 -> assignment SEMICOLON .)


state 134

    (36) function_call -> ID LPARENTHESIS fun_param RPARENTHESIS .

    SEMICOLON       reduce using rule 36 (function_call -> ID LPARENTHESIS fun_param RPARENTHESIS .)
    TIMES           reduce using rule 36 (function_call -> ID LPARENTHESIS fun_param RPARENTHESIS .)
    DIVIDE          reduce using rule 36 (function_call -> ID LPARENTHESIS fun_param RPARENTHESIS .)
    PLUS            reduce using rule 36 (function_call -> ID LPARENTHESIS fun_param RPARENTHESIS .)
    MINUS           reduce using rule 36 (function_call -> ID LPARENTHESIS fun_param RPARENTHESIS .)
    EQUALS          reduce using rule 36 (function_call -> ID LPARENTHESIS fun_param RPARENTHESIS .)
    NOT_EQUALS      reduce using rule 36 (function_call -> ID LPARENTHESIS fun_param RPARENTHESIS .)
    LT              reduce using rule 36 (function_call -> ID LPARENTHESIS fun_param RPARENTHESIS .)
    GT              reduce using rule 36 (function_call -> ID LPARENTHESIS fun_param RPARENTHESIS .)
    LTE             reduce using rule 36 (function_call -> ID LPARENTHESIS fun_param RPARENTHESIS .)
    GTE             reduce using rule 36 (function_call -> ID LPARENTHESIS fun_param RPARENTHESIS .)
    BOOL_NOT        reduce using rule 36 (function_call -> ID LPARENTHESIS fun_param RPARENTHESIS .)
    BOOL_AND        reduce using rule 36 (function_call -> ID LPARENTHESIS fun_param RPARENTHESIS .)
    BOOL_OR         reduce using rule 36 (function_call -> ID LPARENTHESIS fun_param RPARENTHESIS .)
    RPARENTHESIS    reduce using rule 36 (function_call -> ID LPARENTHESIS fun_param RPARENTHESIS .)
    COMMA           reduce using rule 36 (function_call -> ID LPARENTHESIS fun_param RPARENTHESIS .)
    RSQUARE_BRACKET reduce using rule 36 (function_call -> ID LPARENTHESIS fun_param RPARENTHESIS .)


state 135

    (37) fun_param -> expression COMMA . fun_param
    (37) fun_param -> . expression COMMA fun_param
    (38) fun_param -> . expression
    (45) expression -> . exp_or
    (46) expression -> . expression logical_or exp_or
    (47) exp_or -> . exp_and
    (48) exp_or -> . exp_or logical_and exp_and
    (49) exp_and -> . exp_not
    (50) exp_and -> . exp_and logical_not exp_not
    (51) exp_not -> . exp
    (52) exp_not -> . exp relational_l1 term
    (53) exp_not -> . exp relational_l2 term
    (54) exp -> . term
    (55) exp -> . term arithmetic_l1 exp
    (56) term -> . factor
    (57) term -> . factor arithmetic_l2 term
    (58) factor -> . LPARENTHESIS expression RPARENTHESIS
    (59) factor -> . const_var
    (60) factor -> . function_call
    (61) factor -> . var
    (75) const_var -> . CONST_INT
    (76) const_var -> . CONST_FLOAT
    (77) const_var -> . CONST_STRING
    (36) function_call -> . ID LPARENTHESIS fun_param RPARENTHESIS
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    LPARENTHESIS    shift and go to state 61
    CONST_INT       shift and go to state 65
    CONST_FLOAT     shift and go to state 66
    CONST_STRING    shift and go to state 67
    ID              shift and go to state 42

    expression                     shift and go to state 111
    fun_param                      shift and go to state 150
    exp_or                         shift and go to state 55
    exp_and                        shift and go to state 56
    exp_not                        shift and go to state 57
    exp                            shift and go to state 58
    term                           shift and go to state 59
    factor                         shift and go to state 60
    const_var                      shift and go to state 62
    function_call                  shift and go to state 63
    var                            shift and go to state 64

state 136

    (79) var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET .
    (80) var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET . LSQUARE_BRACKET expression RSQUARE_BRACKET

    ASSIGN          reduce using rule 79 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    TIMES           reduce using rule 79 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    DIVIDE          reduce using rule 79 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    PLUS            reduce using rule 79 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    MINUS           reduce using rule 79 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    EQUALS          reduce using rule 79 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    NOT_EQUALS      reduce using rule 79 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    LT              reduce using rule 79 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    GT              reduce using rule 79 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    LTE             reduce using rule 79 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    GTE             reduce using rule 79 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    BOOL_NOT        reduce using rule 79 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    BOOL_AND        reduce using rule 79 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    SEMICOLON       reduce using rule 79 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    BOOL_OR         reduce using rule 79 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    RPARENTHESIS    reduce using rule 79 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    COMMA           reduce using rule 79 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    RSQUARE_BRACKET reduce using rule 79 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    LSQUARE_BRACKET shift and go to state 151


state 137

    (39) write_function -> PRINT LPARENTHESIS write RPARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 152


state 138

    (40) write -> expression COMMA . write
    (40) write -> . expression COMMA write
    (41) write -> . expression
    (45) expression -> . exp_or
    (46) expression -> . expression logical_or exp_or
    (47) exp_or -> . exp_and
    (48) exp_or -> . exp_or logical_and exp_and
    (49) exp_and -> . exp_not
    (50) exp_and -> . exp_and logical_not exp_not
    (51) exp_not -> . exp
    (52) exp_not -> . exp relational_l1 term
    (53) exp_not -> . exp relational_l2 term
    (54) exp -> . term
    (55) exp -> . term arithmetic_l1 exp
    (56) term -> . factor
    (57) term -> . factor arithmetic_l2 term
    (58) factor -> . LPARENTHESIS expression RPARENTHESIS
    (59) factor -> . const_var
    (60) factor -> . function_call
    (61) factor -> . var
    (75) const_var -> . CONST_INT
    (76) const_var -> . CONST_FLOAT
    (77) const_var -> . CONST_STRING
    (36) function_call -> . ID LPARENTHESIS fun_param RPARENTHESIS
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    LPARENTHESIS    shift and go to state 61
    CONST_INT       shift and go to state 65
    CONST_FLOAT     shift and go to state 66
    CONST_STRING    shift and go to state 67
    ID              shift and go to state 42

    expression                     shift and go to state 114
    write                          shift and go to state 153
    exp_or                         shift and go to state 55
    exp_and                        shift and go to state 56
    exp_not                        shift and go to state 57
    exp                            shift and go to state 58
    term                           shift and go to state 59
    factor                         shift and go to state 60
    const_var                      shift and go to state 62
    function_call                  shift and go to state 63
    var                            shift and go to state 64

state 139

    (42) read_function -> READ LPARENTHESIS read RPARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 154


state 140

    (43) read -> expression COMMA . read
    (43) read -> . expression COMMA read
    (44) read -> . expression
    (45) expression -> . exp_or
    (46) expression -> . expression logical_or exp_or
    (47) exp_or -> . exp_and
    (48) exp_or -> . exp_or logical_and exp_and
    (49) exp_and -> . exp_not
    (50) exp_and -> . exp_and logical_not exp_not
    (51) exp_not -> . exp
    (52) exp_not -> . exp relational_l1 term
    (53) exp_not -> . exp relational_l2 term
    (54) exp -> . term
    (55) exp -> . term arithmetic_l1 exp
    (56) term -> . factor
    (57) term -> . factor arithmetic_l2 term
    (58) factor -> . LPARENTHESIS expression RPARENTHESIS
    (59) factor -> . const_var
    (60) factor -> . function_call
    (61) factor -> . var
    (75) const_var -> . CONST_INT
    (76) const_var -> . CONST_FLOAT
    (77) const_var -> . CONST_STRING
    (36) function_call -> . ID LPARENTHESIS fun_param RPARENTHESIS
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    LPARENTHESIS    shift and go to state 61
    CONST_INT       shift and go to state 65
    CONST_FLOAT     shift and go to state 66
    CONST_STRING    shift and go to state 67
    ID              shift and go to state 42

    expression                     shift and go to state 116
    read                           shift and go to state 155
    exp_or                         shift and go to state 55
    exp_and                        shift and go to state 56
    exp_not                        shift and go to state 57
    exp                            shift and go to state 58
    term                           shift and go to state 59
    factor                         shift and go to state 60
    const_var                      shift and go to state 62
    function_call                  shift and go to state 63
    var                            shift and go to state 64

state 141

    (2) functions -> DEF type_fun ID LPARENTHESIS param RPARENTHESIS block . functions
    (2) functions -> . DEF type_fun ID LPARENTHESIS param RPARENTHESIS block functions
    (3) functions -> . empty
    (87) empty -> .

    DEF             shift and go to state 6
    MAIN            reduce using rule 87 (empty -> .)

    functions                      shift and go to state 156
    empty                          shift and go to state 7

state 142

    (4) param -> type ID COMMA . param
    (4) param -> . type ID COMMA param
    (5) param -> . type ID
    (6) param -> . empty
    (81) type -> . INT
    (82) type -> . FLOAT
    (83) type -> . STRING
    (84) type -> . BOOL
    (87) empty -> .

    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    RPARENTHESIS    reduce using rule 87 (empty -> .)

    type                           shift and go to state 78
    param                          shift and go to state 157
    empty                          shift and go to state 79

state 143

    (25) vars_n -> ID LSQUARE_BRACKET CONST_INT RSQUARE_BRACKET LSQUARE_BRACKET CONST_INT . RSQUARE_BRACKET

    RSQUARE_BRACKET shift and go to state 158


state 144

    (27) condition -> IF LPARENTHESIS expression RPARENTHESIS block . condition_else
    (28) condition_else -> . ELSE block
    (29) condition_else -> . empty
    (87) empty -> .

    ELSE            shift and go to state 160
    RETURN          reduce using rule 87 (empty -> .)
    VAR             reduce using rule 87 (empty -> .)
    IF              reduce using rule 87 (empty -> .)
    WHILE           reduce using rule 87 (empty -> .)
    DO              reduce using rule 87 (empty -> .)
    FOR             reduce using rule 87 (empty -> .)
    ID              reduce using rule 87 (empty -> .)
    PRINT           reduce using rule 87 (empty -> .)
    READ            reduce using rule 87 (empty -> .)
    RCURLY_BRACKET  reduce using rule 87 (empty -> .)

    condition_else                 shift and go to state 159
    empty                          shift and go to state 161

state 145

    (30) while_loop -> WHILE LPARENTHESIS expression RPARENTHESIS block .

    RETURN          reduce using rule 30 (while_loop -> WHILE LPARENTHESIS expression RPARENTHESIS block .)
    VAR             reduce using rule 30 (while_loop -> WHILE LPARENTHESIS expression RPARENTHESIS block .)
    IF              reduce using rule 30 (while_loop -> WHILE LPARENTHESIS expression RPARENTHESIS block .)
    WHILE           reduce using rule 30 (while_loop -> WHILE LPARENTHESIS expression RPARENTHESIS block .)
    DO              reduce using rule 30 (while_loop -> WHILE LPARENTHESIS expression RPARENTHESIS block .)
    FOR             reduce using rule 30 (while_loop -> WHILE LPARENTHESIS expression RPARENTHESIS block .)
    ID              reduce using rule 30 (while_loop -> WHILE LPARENTHESIS expression RPARENTHESIS block .)
    PRINT           reduce using rule 30 (while_loop -> WHILE LPARENTHESIS expression RPARENTHESIS block .)
    READ            reduce using rule 30 (while_loop -> WHILE LPARENTHESIS expression RPARENTHESIS block .)
    RCURLY_BRACKET  reduce using rule 30 (while_loop -> WHILE LPARENTHESIS expression RPARENTHESIS block .)


state 146

    (31) while_loop -> DO block WHILE LPARENTHESIS expression . RPARENTHESIS SEMICOLON
    (46) expression -> expression . logical_or exp_or
    (72) logical_or -> . BOOL_OR

    RPARENTHESIS    shift and go to state 162
    BOOL_OR         shift and go to state 83

    logical_or                     shift and go to state 82

state 147

    (32) for_loop -> FOR LPARENTHESIS for_param1 for_param2 for_param3 . RPARENTHESIS block

    RPARENTHESIS    shift and go to state 163


state 148

    (35) for_param3 -> assignment .

    RPARENTHESIS    reduce using rule 35 (for_param3 -> assignment .)


state 149

    (34) for_param2 -> expression SEMICOLON .

    ID              reduce using rule 34 (for_param2 -> expression SEMICOLON .)


state 150

    (37) fun_param -> expression COMMA fun_param .

    RPARENTHESIS    reduce using rule 37 (fun_param -> expression COMMA fun_param .)


state 151

    (80) var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET . expression RSQUARE_BRACKET
    (45) expression -> . exp_or
    (46) expression -> . expression logical_or exp_or
    (47) exp_or -> . exp_and
    (48) exp_or -> . exp_or logical_and exp_and
    (49) exp_and -> . exp_not
    (50) exp_and -> . exp_and logical_not exp_not
    (51) exp_not -> . exp
    (52) exp_not -> . exp relational_l1 term
    (53) exp_not -> . exp relational_l2 term
    (54) exp -> . term
    (55) exp -> . term arithmetic_l1 exp
    (56) term -> . factor
    (57) term -> . factor arithmetic_l2 term
    (58) factor -> . LPARENTHESIS expression RPARENTHESIS
    (59) factor -> . const_var
    (60) factor -> . function_call
    (61) factor -> . var
    (75) const_var -> . CONST_INT
    (76) const_var -> . CONST_FLOAT
    (77) const_var -> . CONST_STRING
    (36) function_call -> . ID LPARENTHESIS fun_param RPARENTHESIS
    (78) var -> . ID
    (79) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET
    (80) var -> . ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET

    LPARENTHESIS    shift and go to state 61
    CONST_INT       shift and go to state 65
    CONST_FLOAT     shift and go to state 66
    CONST_STRING    shift and go to state 67
    ID              shift and go to state 42

    expression                     shift and go to state 164
    exp_or                         shift and go to state 55
    exp_and                        shift and go to state 56
    exp_not                        shift and go to state 57
    exp                            shift and go to state 58
    term                           shift and go to state 59
    factor                         shift and go to state 60
    const_var                      shift and go to state 62
    function_call                  shift and go to state 63
    var                            shift and go to state 64

state 152

    (39) write_function -> PRINT LPARENTHESIS write RPARENTHESIS SEMICOLON .

    RETURN          reduce using rule 39 (write_function -> PRINT LPARENTHESIS write RPARENTHESIS SEMICOLON .)
    VAR             reduce using rule 39 (write_function -> PRINT LPARENTHESIS write RPARENTHESIS SEMICOLON .)
    IF              reduce using rule 39 (write_function -> PRINT LPARENTHESIS write RPARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 39 (write_function -> PRINT LPARENTHESIS write RPARENTHESIS SEMICOLON .)
    DO              reduce using rule 39 (write_function -> PRINT LPARENTHESIS write RPARENTHESIS SEMICOLON .)
    FOR             reduce using rule 39 (write_function -> PRINT LPARENTHESIS write RPARENTHESIS SEMICOLON .)
    ID              reduce using rule 39 (write_function -> PRINT LPARENTHESIS write RPARENTHESIS SEMICOLON .)
    PRINT           reduce using rule 39 (write_function -> PRINT LPARENTHESIS write RPARENTHESIS SEMICOLON .)
    READ            reduce using rule 39 (write_function -> PRINT LPARENTHESIS write RPARENTHESIS SEMICOLON .)
    RCURLY_BRACKET  reduce using rule 39 (write_function -> PRINT LPARENTHESIS write RPARENTHESIS SEMICOLON .)


state 153

    (40) write -> expression COMMA write .

    RPARENTHESIS    reduce using rule 40 (write -> expression COMMA write .)


state 154

    (42) read_function -> READ LPARENTHESIS read RPARENTHESIS SEMICOLON .

    RETURN          reduce using rule 42 (read_function -> READ LPARENTHESIS read RPARENTHESIS SEMICOLON .)
    VAR             reduce using rule 42 (read_function -> READ LPARENTHESIS read RPARENTHESIS SEMICOLON .)
    IF              reduce using rule 42 (read_function -> READ LPARENTHESIS read RPARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 42 (read_function -> READ LPARENTHESIS read RPARENTHESIS SEMICOLON .)
    DO              reduce using rule 42 (read_function -> READ LPARENTHESIS read RPARENTHESIS SEMICOLON .)
    FOR             reduce using rule 42 (read_function -> READ LPARENTHESIS read RPARENTHESIS SEMICOLON .)
    ID              reduce using rule 42 (read_function -> READ LPARENTHESIS read RPARENTHESIS SEMICOLON .)
    PRINT           reduce using rule 42 (read_function -> READ LPARENTHESIS read RPARENTHESIS SEMICOLON .)
    READ            reduce using rule 42 (read_function -> READ LPARENTHESIS read RPARENTHESIS SEMICOLON .)
    RCURLY_BRACKET  reduce using rule 42 (read_function -> READ LPARENTHESIS read RPARENTHESIS SEMICOLON .)


state 155

    (43) read -> expression COMMA read .

    RPARENTHESIS    reduce using rule 43 (read -> expression COMMA read .)


state 156

    (2) functions -> DEF type_fun ID LPARENTHESIS param RPARENTHESIS block functions .

    MAIN            reduce using rule 2 (functions -> DEF type_fun ID LPARENTHESIS param RPARENTHESIS block functions .)


state 157

    (4) param -> type ID COMMA param .

    RPARENTHESIS    reduce using rule 4 (param -> type ID COMMA param .)


state 158

    (25) vars_n -> ID LSQUARE_BRACKET CONST_INT RSQUARE_BRACKET LSQUARE_BRACKET CONST_INT RSQUARE_BRACKET .

    SEMICOLON       reduce using rule 25 (vars_n -> ID LSQUARE_BRACKET CONST_INT RSQUARE_BRACKET LSQUARE_BRACKET CONST_INT RSQUARE_BRACKET .)


state 159

    (27) condition -> IF LPARENTHESIS expression RPARENTHESIS block condition_else .

    RETURN          reduce using rule 27 (condition -> IF LPARENTHESIS expression RPARENTHESIS block condition_else .)
    VAR             reduce using rule 27 (condition -> IF LPARENTHESIS expression RPARENTHESIS block condition_else .)
    IF              reduce using rule 27 (condition -> IF LPARENTHESIS expression RPARENTHESIS block condition_else .)
    WHILE           reduce using rule 27 (condition -> IF LPARENTHESIS expression RPARENTHESIS block condition_else .)
    DO              reduce using rule 27 (condition -> IF LPARENTHESIS expression RPARENTHESIS block condition_else .)
    FOR             reduce using rule 27 (condition -> IF LPARENTHESIS expression RPARENTHESIS block condition_else .)
    ID              reduce using rule 27 (condition -> IF LPARENTHESIS expression RPARENTHESIS block condition_else .)
    PRINT           reduce using rule 27 (condition -> IF LPARENTHESIS expression RPARENTHESIS block condition_else .)
    READ            reduce using rule 27 (condition -> IF LPARENTHESIS expression RPARENTHESIS block condition_else .)
    RCURLY_BRACKET  reduce using rule 27 (condition -> IF LPARENTHESIS expression RPARENTHESIS block condition_else .)


state 160

    (28) condition_else -> ELSE . block
    (7) block -> . LCURLY_BRACKET content_block RCURLY_BRACKET

    LCURLY_BRACKET  shift and go to state 20

    block                          shift and go to state 165

state 161

    (29) condition_else -> empty .

    RETURN          reduce using rule 29 (condition_else -> empty .)
    VAR             reduce using rule 29 (condition_else -> empty .)
    IF              reduce using rule 29 (condition_else -> empty .)
    WHILE           reduce using rule 29 (condition_else -> empty .)
    DO              reduce using rule 29 (condition_else -> empty .)
    FOR             reduce using rule 29 (condition_else -> empty .)
    ID              reduce using rule 29 (condition_else -> empty .)
    PRINT           reduce using rule 29 (condition_else -> empty .)
    READ            reduce using rule 29 (condition_else -> empty .)
    RCURLY_BRACKET  reduce using rule 29 (condition_else -> empty .)


state 162

    (31) while_loop -> DO block WHILE LPARENTHESIS expression RPARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 166


state 163

    (32) for_loop -> FOR LPARENTHESIS for_param1 for_param2 for_param3 RPARENTHESIS . block
    (7) block -> . LCURLY_BRACKET content_block RCURLY_BRACKET

    LCURLY_BRACKET  shift and go to state 20

    block                          shift and go to state 167

state 164

    (80) var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression . RSQUARE_BRACKET
    (46) expression -> expression . logical_or exp_or
    (72) logical_or -> . BOOL_OR

    RSQUARE_BRACKET shift and go to state 168
    BOOL_OR         shift and go to state 83

    logical_or                     shift and go to state 82

state 165

    (28) condition_else -> ELSE block .

    RETURN          reduce using rule 28 (condition_else -> ELSE block .)
    VAR             reduce using rule 28 (condition_else -> ELSE block .)
    IF              reduce using rule 28 (condition_else -> ELSE block .)
    WHILE           reduce using rule 28 (condition_else -> ELSE block .)
    DO              reduce using rule 28 (condition_else -> ELSE block .)
    FOR             reduce using rule 28 (condition_else -> ELSE block .)
    ID              reduce using rule 28 (condition_else -> ELSE block .)
    PRINT           reduce using rule 28 (condition_else -> ELSE block .)
    READ            reduce using rule 28 (condition_else -> ELSE block .)
    RCURLY_BRACKET  reduce using rule 28 (condition_else -> ELSE block .)


state 166

    (31) while_loop -> DO block WHILE LPARENTHESIS expression RPARENTHESIS SEMICOLON .

    RETURN          reduce using rule 31 (while_loop -> DO block WHILE LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    VAR             reduce using rule 31 (while_loop -> DO block WHILE LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    IF              reduce using rule 31 (while_loop -> DO block WHILE LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 31 (while_loop -> DO block WHILE LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    DO              reduce using rule 31 (while_loop -> DO block WHILE LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    FOR             reduce using rule 31 (while_loop -> DO block WHILE LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    ID              reduce using rule 31 (while_loop -> DO block WHILE LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    PRINT           reduce using rule 31 (while_loop -> DO block WHILE LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    READ            reduce using rule 31 (while_loop -> DO block WHILE LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    RCURLY_BRACKET  reduce using rule 31 (while_loop -> DO block WHILE LPARENTHESIS expression RPARENTHESIS SEMICOLON .)


state 167

    (32) for_loop -> FOR LPARENTHESIS for_param1 for_param2 for_param3 RPARENTHESIS block .

    RETURN          reduce using rule 32 (for_loop -> FOR LPARENTHESIS for_param1 for_param2 for_param3 RPARENTHESIS block .)
    VAR             reduce using rule 32 (for_loop -> FOR LPARENTHESIS for_param1 for_param2 for_param3 RPARENTHESIS block .)
    IF              reduce using rule 32 (for_loop -> FOR LPARENTHESIS for_param1 for_param2 for_param3 RPARENTHESIS block .)
    WHILE           reduce using rule 32 (for_loop -> FOR LPARENTHESIS for_param1 for_param2 for_param3 RPARENTHESIS block .)
    DO              reduce using rule 32 (for_loop -> FOR LPARENTHESIS for_param1 for_param2 for_param3 RPARENTHESIS block .)
    FOR             reduce using rule 32 (for_loop -> FOR LPARENTHESIS for_param1 for_param2 for_param3 RPARENTHESIS block .)
    ID              reduce using rule 32 (for_loop -> FOR LPARENTHESIS for_param1 for_param2 for_param3 RPARENTHESIS block .)
    PRINT           reduce using rule 32 (for_loop -> FOR LPARENTHESIS for_param1 for_param2 for_param3 RPARENTHESIS block .)
    READ            reduce using rule 32 (for_loop -> FOR LPARENTHESIS for_param1 for_param2 for_param3 RPARENTHESIS block .)
    RCURLY_BRACKET  reduce using rule 32 (for_loop -> FOR LPARENTHESIS for_param1 for_param2 for_param3 RPARENTHESIS block .)


state 168

    (80) var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET .

    ASSIGN          reduce using rule 80 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    TIMES           reduce using rule 80 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    DIVIDE          reduce using rule 80 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    PLUS            reduce using rule 80 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    MINUS           reduce using rule 80 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    EQUALS          reduce using rule 80 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    NOT_EQUALS      reduce using rule 80 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    LT              reduce using rule 80 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    GT              reduce using rule 80 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    LTE             reduce using rule 80 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    GTE             reduce using rule 80 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    BOOL_NOT        reduce using rule 80 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    BOOL_AND        reduce using rule 80 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    SEMICOLON       reduce using rule 80 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    BOOL_OR         reduce using rule 80 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    RPARENTHESIS    reduce using rule 80 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    COMMA           reduce using rule 80 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET .)
    RSQUARE_BRACKET reduce using rule 80 (var -> ID LSQUARE_BRACKET expression RSQUARE_BRACKET LSQUARE_BRACKET expression RSQUARE_BRACKET .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RETURN in state 20 resolved as shift
WARNING: shift/reduce conflict for VAR in state 20 resolved as shift
WARNING: shift/reduce conflict for IF in state 20 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 20 resolved as shift
WARNING: shift/reduce conflict for DO in state 20 resolved as shift
WARNING: shift/reduce conflict for FOR in state 20 resolved as shift
WARNING: shift/reduce conflict for ID in state 20 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 20 resolved as shift
WARNING: shift/reduce conflict for READ in state 20 resolved as shift
WARNING: shift/reduce conflict for VAR in state 22 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 26 resolved as shift
WARNING: shift/reduce conflict for VAR in state 26 resolved as shift
WARNING: shift/reduce conflict for IF in state 26 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 26 resolved as shift
WARNING: shift/reduce conflict for DO in state 26 resolved as shift
WARNING: shift/reduce conflict for FOR in state 26 resolved as shift
WARNING: shift/reduce conflict for ID in state 26 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 26 resolved as shift
WARNING: shift/reduce conflict for READ in state 26 resolved as shift
WARNING: reduce/reduce conflict in state 27 resolved using rule (content_block -> empty)
WARNING: rejected rule (def_vars -> empty) in state 27
